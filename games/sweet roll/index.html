<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Time: One Sweet Roll - Level System</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #050c1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #gameContainer { position: relative; border: 10px solid #ff4d94; border-radius: 15px; box-shadow: 0 0 50px rgba(0,0,0,0.7); }
        canvas { display: block; background: #4cc9f0; cursor: crosshair; }
        #ui { position: absolute; top: 15px; width: 100%; text-align: center; color: #fff; font-size: 22px; font-weight: bold; text-shadow: 3px 3px #ff4d94; pointer-events: none; }
        #lvlDisplay { position: absolute; top: 15px; left: 20px; color: #fff; font-size: 24px; text-shadow: 2px 2px #000; pointer-events: none; }
    </style>
</head>
<body>

<div id="gameContainer">
    <div id="lvlDisplay">Level: 1</div>
    <div id="ui">AVOID SPIKES! CLICK BLOCKS TO CLEAR A PATH!</div>
    <canvas id="gameCanvas" width="960" height="640"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRID = 80;
const ROWS = 8;
const COLS = 12;

let blocks = [];
let gameState = 'PLAYING';
let portalPulse = 0;
let currentLevel = 1;

let bun = {
    x: GRID * 0.5 + 40,
    y: GRID * 3.5,
    radius: 28,
    vx: 1.3,
    vy: 0,
    rotation: 0
};

const portal = { x: GRID * 11.5, y: GRID * 4.5, radius: 35 };

function initLevel() {
    blocks = [];
    document.getElementById('lvlDisplay').innerText = `Level: ${currentLevel}`;
    const colors = ['#ffffff', '#e1f5fe', '#b3e5fc', '#81d4fa'];
    
    // Determine the "Safe Corridor" row for this level (guaranteed no spikes)
    const safeRow = Math.floor(Math.random() * 3) + 3; // Randomly pick row 3, 4, or 5
    
    const emptySlots = [
        {r: 3, c: 0}, {r: 3, c: 1}, {r: 4, c: 11}, {r: 5, c: 11}
    ];

    // Increase spike density slightly per level, maxing out at 35%
    let spikeChance = Math.min(0.15 + (currentLevel * 0.02), 0.35);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const isEmpty = emptySlots.some(slot => slot.r === r && slot.c === c);
            if (isEmpty) continue;

            let type = 'ice';
            // Only place spikes if NOT in the safe row and not at the very start/end
            if (r !== safeRow && c > 1 && c < 10) {
                if (Math.random() < spikeChance) {
                    type = 'spike';
                }
            }

            blocks.push({
                x: c * GRID,
                y: r * GRID,
                color: colors[Math.floor(Math.random() * colors.length)],
                active: true,
                type: type
            });
        }
    }
}

function update() {
    if (gameState !== 'PLAYING') return;
    portalPulse += 0.05;

    let onGround = false;
    let blocked = false;

    if (bun.y > canvas.height + 50 || bun.x > canvas.width + 50 || bun.x < -50) {
        return fail("The Bun disappeared!");
    }

    blocks.forEach(b => {
        if (!b.active) return;
        const bx = b.x, by = b.y;
        
        if (bun.x + 15 > bx && bun.x - 15 < bx + GRID) {
            if (bun.y + bun.radius > by && bun.y + bun.radius < by + 25) {
                if (b.type === 'spike') return fail("POKE! You hit a spike!");
                onGround = true;
                bun.vy = 0;
                bun.y = by - bun.radius;
            }
        }

        if (bun.y + 10 > by && bun.y - 10 < by + GRID) {
            if (bun.x + bun.radius > bx && bun.x + bun.radius < bx + 15) {
                if (b.type === 'spike') return fail("OUCH! Spikes are dangerous!");
                blocked = true;
            }
        }
    });

    if (!onGround) bun.vy += 0.45;
    bun.y += bun.vy;

    if (!blocked) {
        bun.x += bun.vx;
        bun.rotation += 0.08;
    }

    if (Math.hypot(bun.x - portal.x, bun.y - portal.y) < 40) {
        currentLevel++;
        bun.vx += 0.1; // Speed increases slightly
        alert(`Victory! Moving to Level ${currentLevel}`);
        reset();
    }
}

function drawBackground() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            ctx.fillStyle = (r + c) % 2 === 0 ? '#4cc9f0' : '#48bfe3';
            ctx.fillRect(c * GRID, r * GRID, GRID, GRID);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.strokeRect(c * GRID, r * GRID, GRID, GRID);
        }
    }
}

function draw() {
    drawBackground();

    blocks.forEach(b => {
        if (!b.active) return;
        if (b.type === 'ice') {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x + 2, b.y + 2, GRID - 4, GRID - 4);
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath();
            ctx.moveTo(b.x + 10, b.y + 10); ctx.lineTo(b.x + 30, b.y + 15);
            ctx.stroke();
        } else {
            ctx.fillStyle = '#ff5252';
            ctx.fillRect(b.x + 2, b.y + 2, GRID - 4, GRID - 4);
            ctx.fillStyle = '#b71c1c';
            for(let i=0; i<3; i++) {
                ctx.beginPath();
                ctx.moveTo(b.x + 15 + i*25, b.y + GRID - 5);
                ctx.lineTo(b.x + 27 + i*25, b.y + 15);
                ctx.lineTo(b.x + 40 + i*25, b.y + GRID - 5);
                ctx.fill();
            }
        }
    });

    const pSize = 30 + Math.sin(portalPulse) * 5;
    ctx.shadowBlur = 20; ctx.shadowColor = "#00ffff";
    ctx.fillStyle = "white";
    ctx.beginPath(); ctx.arc(portal.x, portal.y, pSize, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;

    ctx.save();
    ctx.translate(bun.x, bun.y);
    ctx.rotate(bun.rotation);
    ctx.fillStyle = "#e6b38a";
    ctx.beginPath(); ctx.arc(0, 0, bun.radius, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#8b5a2b"; ctx.lineWidth = 3; ctx.stroke();
    ctx.restore();

    update();
    requestAnimationFrame(draw);
}

function fail(msg) {
    gameState = 'FAIL';
    alert(msg);
    currentLevel = 1; // Reset to level 1 on fail
    bun.vx = 1.3;
    reset();
}

function reset() {
    bun.x = GRID * 0.5 + 40; bun.y = GRID * 3.5;
    bun.vy = 0;
    gameState = 'PLAYING';
    initLevel();
}

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (Math.hypot(mx - bun.x, my - bun.y) < bun.radius + 10) {
        if (bun.vy === 0) bun.vy = -11;
        return;
    }

    blocks.forEach(b => {
        if (mx > b.x && mx < b.x + GRID && my > b.y && my < b.y + GRID) {
            if (b.type === 'ice') b.active = false;
        }
    });
});

initLevel();
draw();
</script>
</body>
</html>