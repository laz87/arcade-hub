<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Ball</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        

         /* --- Ambient Neon Background --- */
        .neon-bg {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .neon-item {
            position: absolute;
            user-select: none;
            filter: blur(2px);
            animation: neon-float 15s infinite ease-in-out;
        }

        /* Ladybug Symbol */
        .ladybug::before {
            content: 'âš½';
            filter: drop-shadow(0 0 10px currentColor);
        }

        /* Light Orbs */
        .light-orb {
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.4;
            animation: orb-pulse 8s infinite ease-in-out;
        }

        @keyframes neon-float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(60px, -80px) rotate(25deg); }
            66% { transform: translate(-40px, 40px) rotate(-15deg); }
        }

        @keyframes orb-pulse {
            0%, 100% { transform: scale(1); opacity: 0.2; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }




          /* Graffiti Title */
        #gameTitle {
            font-family: 'Permanent Marker', cursive;
            font-size: 3rem;
            color: #fff;
            text-transform: uppercase;
            margin-bottom: 10px;
            text-shadow: 
                0 0 10px #fff,
                0 0 20px #ff00ff,
                0 0 40px #ff00ff,
                2px 2px 0px #00ffff;
            transform: rotate(-3deg);
            z-index: 10;
        }

        #gameContainer {
            position: relative;
            width: 95vw;
            height: 95vw;
            max-width: 600px;
            max-height: 600px;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
        }
        
        #ui {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            color: #00ffff;
        }
        
        #levelDisplay { position: absolute; top: 15px; left: 15px; font-size: 18px; text-shadow: 0 0 10px #00ffff; }
        #timer { position: absolute; top: 15px; right: 15px; font-size: 16px; }
        
        /* Neon Mute Button */
        #muteBtn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: transparent;
            color: #ff00ff;
            border: 2px solid #ff00ff;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 0 10px #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            pointer-events: auto;
            z-index: 100;
            transition: 0.2s;
        }

        #muteBtn.muted {
            color: #555;
            border-color: #555;
            box-shadow: none;
            text-shadow: none;
        }

        #levelComplete {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            text-align: center;
            text-shadow: 0 0 20px #00ff00;
            color: #00ff00;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #levelComplete.show { opacity: 1; }

        #joystickContainer {
            position: fixed;
            bottom: 30px; left: 30px;
            width: 100px; height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        #joystickKnob {
            position: absolute;
            top: 50%; left: 50%;
            width: 40px; height: 40px;
            background: #00ffff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #00ffff;
        }

        @media (pointer: coarse) { #joystickContainer { display: block; } }
    </style>
</head>
<body>


    <div class="neon-item ladybug" style="left: 10%; top: 15%; font-size: 4rem; color: #ff0055; animation-delay: 0s;"></div>
        <div class="neon-item ladybug" style="right: 15%; top: 10%; font-size: 3rem; color: #00ff99; animation-delay: 2s;"></div>
        <div class="neon-item ladybug" style="left: 20%; bottom: 15%; font-size: 5rem; color: #00ffff; animation-delay: 4s;"></div>
        <div class="neon-item ladybug" style="right: 5%; bottom: 20%; font-size: 4.5rem; color: #ff00ff; animation-delay: 1s;"></div>
        
        <div class="neon-tube" style="left: 5%; top: 20%; background: #00ffff; box-shadow: 0 0 20px #00ffff;"></div>
    <div class="neon-tube" style="right: 8%; bottom: 10%; background: #ff00ff; box-shadow: 0 0 20px #ff00ff;"></div>
    
    <div class="pulse-ring" style="left: 50%; top: 50%; animation-delay: 0s;"></div>
    <div class="pulse-ring" style="left: 50%; top: 50%; animation-delay: 3s; border-color: #ff00ff;"></div>
        
        <div class="neon-item light-orb" style="left: 50%; top: 20%; width: 100px; height: 100px; background: #00ffff; animation-duration: 10s;"></div>
        <div class="neon-item light-orb" style="right: 30%; bottom: 10%; width: 150px; height: 150px; background: #ff00ff; animation-duration: 12s;"></div>
        <div class="neon-item light-orb" style="left: 5%; bottom: 40%; width: 80px; height: 80px; background: #ffff00; animation-duration: 7s;"></div>

        <div class="pulse-ring" style="left: 50%; top: 50%; animation-delay: 0s;"></div>
    <div class="pulse-ring" style="left: 50%; top: 50%; animation-delay: 3s; border-color: #ff00ff;"></div>

    <div class="neon-item light-orb" style="left: 70%; top: 20%; width: 120px; height: 120px; background: #0044ff;"></div>
    <div class="neon-item light-orb" style="left: 10%; bottom: 30%; width: 90px; height: 90px; background: #ff0055;"></div>
    </div>



    <h1 id="gameTitle">Neon Ball</h1>
    <button id="muteBtn">Audio: ON</button>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="levelDisplay">Level 1</div>
            <div id="timer">0:00</div>
            <div id="levelComplete">LEVEL COMPLETE!</div>
        </div>
    </div>

    <div id="joystickContainer"><div id="joystickKnob"></div></div>

    <script>
        // ========== AUDIO ENGINE (Synthesized) ==========
        const AudioEngine = (() => {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            let isMuted = false;
            let bgOsc = null;
            let bgGain = null;

            const playSound = (freq, type, duration, volume) => {
                if (isMuted || ctx.state === 'suspended') return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, ctx.currentTime);
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            };

            return {
                toggle: () => { 
                    isMuted = !isMuted; 
                    if(isMuted && bgGain) bgGain.gain.setTargetAtTime(0, ctx.currentTime, 0.1);
                    else if(bgGain) bgGain.gain.setTargetAtTime(0.05, ctx.currentTime, 0.1);
                    return isMuted; 
                },
                startMusic: () => {
                    if (bgOsc) return;
                    bgGain = ctx.createGain();
                    bgGain.gain.value = isMuted ? 0 : 0.05;
                    bgGain.connect(ctx.destination);
                    
                    const playNote = () => {
                        const osc = ctx.createOscillator();
                        osc.type = 'triangle';
                        // Ethereal minor scale melody
                        const notes = [164.81, 196.00, 220.00, 246.94];
                        osc.frequency.value = notes[Math.floor(Math.random()*notes.length)];
                        osc.connect(bgGain);
                        osc.start();
                        osc.stop(ctx.currentTime + 2);
                        setTimeout(playNote, 2000);
                    };
                    playNote();
                },
                playBounce: () => playSound(150, 'sine', 0.1, 0.1),
                playWin: () => {
                    playSound(440, 'square', 0.2, 0.1);
                    setTimeout(() => playSound(880, 'square', 0.4, 0.1), 150);
                },
                resume: () => ctx.resume()
            };
        })();

        // ========== GAME LOGIC ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800; canvas.height = 800;

        let level = 1, mazeSize = 10, cellSize = 60, maze = [];
        let player = { x: 0, y: 0, vx: 0, vy: 0, radius: 12, maxSpeed: 5, acceleration: 0.4, friction: 0.92 };
        let exit = { x: 0, y: 0 }, keys = {}, gameState = 'playing', transitionAlpha = 0, levelStartTime = Date.now();

        // Mute Toggle Listener
        document.getElementById('muteBtn').addEventListener('click', (e) => {
            AudioEngine.resume();
            AudioEngine.startMusic();
            const muted = AudioEngine.toggle();
            e.target.textContent = muted ? "Audio: OFF" : "Audio: ON";
            e.target.classList.toggle('muted', muted);
        });

        // Joystick Logic
        let touchActive = false, joystickPos = { x: 0, y: 0 };
        const joystickBase = document.getElementById('joystickContainer'), knob = document.getElementById('joystickKnob');

        const handleTouch = (e) => {
            AudioEngine.resume(); // Unlock audio on first touch
            AudioEngine.startMusic();
            if (e.touches.length > 0) {
                touchActive = true;
                const rect = joystickBase.getBoundingClientRect();
                const dx = e.touches[0].clientX - (rect.left + rect.width/2);
                const dy = e.touches[0].clientY - (rect.top + rect.height/2);
                const dist = Math.min(rect.width/2, Math.sqrt(dx*dx + dy*dy));
                const angle = Math.atan2(dy, dx);
                joystickPos = { x: Math.cos(angle) * (dist/(rect.width/2)), y: Math.sin(angle) * (dist/(rect.width/2)) };
                knob.style.transform = `translate(calc(-50% + ${dx*(dist/Math.hypot(dx,dy))}px), calc(-50% + ${dy*(dist/Math.hypot(dx,dy))}px))`;
            }
        };
        joystickBase.addEventListener('touchstart', handleTouch);
        joystickBase.addEventListener('touchmove', handleTouch);
        joystickBase.addEventListener('touchend', () => { touchActive = false; joystickPos = {x:0,y:0}; knob.style.transform = `translate(-50%, -50%)`; });

        // Maze Gen
        function generateMaze(size) {
            const grid = Array.from({length: size}, (_, y) => Array.from({length: size}, (_, x) => ({x, y, walls: {top:true,right:true,bottom:true,left:true}, visited: false})));
            const stack = [];
            const start = grid[0][0]; start.visited = true; stack.push(start);
            while (stack.length > 0) {
                const curr = stack[stack.length - 1];
                const neighbors = [];
                const {x, y} = curr;
                if (y > 0 && !grid[y-1][x].visited) neighbors.push(grid[y-1][x]);
                if (x < size-1 && !grid[y][x+1].visited) neighbors.push(grid[y][x+1]);
                if (y < size-1 && !grid[y+1][x].visited) neighbors.push(grid[y+1][x]);
                if (x > 0 && !grid[y][x-1].visited) neighbors.push(grid[y][x-1]);
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    if (next.x > curr.x) { curr.walls.right = false; next.walls.left = false; }
                    else if (next.x < curr.x) { curr.walls.left = false; next.walls.right = false; }
                    else if (next.y > curr.y) { curr.walls.bottom = false; next.walls.top = false; }
                    else if (next.y < curr.y) { curr.walls.top = false; next.walls.bottom = false; }
                    next.visited = true; stack.push(next);
                } else stack.pop();
            }
            return grid;
        }

        function resolveWall(x1, y1, x2, y2) {
            const dx = x2 - x1, dy = y2 - y1;
            const t = Math.max(0, Math.min(1, ((player.x - x1) * dx + (player.y - y1) * dy) / (dx * dx + dy * dy)));
            const nx = x1 + t * dx, ny = y1 + t * dy;
            const dist = Math.hypot(player.x - nx, player.y - ny);
            if (dist < player.radius) {
                AudioEngine.playBounce();
                const overlap = player.radius - dist;
                const normX = (player.x - nx) / dist, normY = (player.y - ny) / dist;
                player.x += normX * overlap; player.y += normY * overlap;
                const dot = player.vx * normX + player.vy * normY;
                player.vx -= 1.6 * dot * normX; player.vy -= 1.6 * dot * normY;
            }
        }

        function update() {
            if (touchActive) { player.vx += joystickPos.x * player.acceleration; player.vy += joystickPos.y * player.acceleration; }
            else {
                if (keys['ArrowUp'] || keys['w']) player.vy -= player.acceleration;
                if (keys['ArrowDown'] || keys['s']) player.vy += player.acceleration;
                if (keys['ArrowLeft'] || keys['a']) player.vx -= player.acceleration;
                if (keys['ArrowRight'] || keys['d']) player.vx += player.acceleration;
            }
            player.vx *= player.friction; player.vy *= player.friction;
            player.x += player.vx; player.y += player.vy;
            const cx = Math.floor(player.x / cellSize), cy = Math.floor(player.y / cellSize);
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = cx + dx, ny = cy + dy;
                    if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize) {
                        const cell = maze[ny][nx], x = cell.x * cellSize, y = cell.y * cellSize;
                        if (cell.walls.top) resolveWall(x, y, x + cellSize, y);
                        if (cell.walls.right) resolveWall(x + cellSize, y, x + cellSize, y + cellSize);
                        if (cell.walls.bottom) resolveWall(x, y + cellSize, x + cellSize, y + cellSize);
                        if (cell.walls.left) resolveWall(x, y, x, y + cellSize);
                    }
                }
            }
            if (Math.hypot(player.x - exit.x, player.y - exit.y) < 30 && gameState === 'playing') levelComplete();
        }

        function render() {
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            maze.forEach(row => row.forEach(cell => {
                const dist = Math.hypot(cell.x * cellSize + cellSize/2 - player.x, cell.y * cellSize + cellSize/2 - player.y);
                const opacity = Math.max(0, 1 - dist / 250);
                if (opacity <= 0) return;
                ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`; ctx.lineWidth = 4;
                ctx.beginPath(); const x = cell.x * cellSize, y = cell.y * cellSize;
                if (cell.walls.top) { ctx.moveTo(x, y); ctx.lineTo(x+cellSize, y); }
                if (cell.walls.right) { ctx.moveTo(x+cellSize, y); ctx.lineTo(x+cellSize, y+cellSize); }
                if (cell.walls.bottom) { ctx.moveTo(x, y+cellSize); ctx.lineTo(x+cellSize, y+cellSize); }
                if (cell.walls.left) { ctx.moveTo(x, y); ctx.lineTo(x, y+cellSize); }
                ctx.stroke();
            }));
            const exitDist = Math.hypot(exit.x - player.x, exit.y - player.y);
            const exitOp = Math.max(0, 1 - exitDist / 250);
            if (exitOp > 0) {
                ctx.fillStyle = `rgba(0, 255, 0, ${exitOp})`;
                ctx.beginPath(); ctx.arc(exit.x, exit.y, 12 + Math.sin(Date.now()/200)*3, 0, Math.PI*2); ctx.fill();
            }
            ctx.fillStyle = '#00ffff'; ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
            ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            if (gameState === 'transitioning') { ctx.fillStyle = `rgba(10, 10, 10, ${transitionAlpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        }

        function initLevel() {
            mazeSize = 8 + (level * 2); cellSize = canvas.width / mazeSize;
            maze = generateMaze(mazeSize); player.x = cellSize / 2; player.y = cellSize / 2;
            player.vx = 0; player.vy = 0; exit = { x: (mazeSize - 0.5) * cellSize, y: (mazeSize - 0.5) * cellSize };
            document.getElementById('levelDisplay').textContent = `Level ${level}`; levelStartTime = Date.now();
        }

        function levelComplete() {
            AudioEngine.playWin();
            gameState = 'transitioning';
            document.getElementById('levelComplete').classList.add('show');
            let fade = setInterval(() => {
                transitionAlpha += 0.1;
                if (transitionAlpha >= 1) {
                    clearInterval(fade); level++; initLevel();
                    setTimeout(() => {
                        document.getElementById('levelComplete').classList.remove('show');
                        let fadeIn = setInterval(() => {
                            transitionAlpha -= 0.1;
                            if (transitionAlpha <= 0) { clearInterval(fadeIn); gameState = 'playing'; }
                        }, 30);
                    }, 1000);
                }
            }, 50);
        }

        function loop() {
            if (gameState === 'playing') {
                update();
                const elapsed = Math.floor((Date.now() - levelStartTime) / 1000);
                document.getElementById('timer').textContent = `${Math.floor(elapsed/60)}:${(elapsed%60).toString().padStart(2,'0')}`;
            }
            render(); requestAnimationFrame(loop);
        }

        document.addEventListener('keydown', e => { 
            AudioEngine.resume(); AudioEngine.startMusic();
            keys[e.key] = true; 
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        initLevel();
        loop();
    </script>
</body>
</html>