<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clone Protocol</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a14 0%, #1a0b2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 255, 255, 0.4);
        }
        
        canvas {
            display: block;
            background: #0a0a14;
            image-rendering: pixelated;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            color: #00ffff;
        }
        
        #levelInfo {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 20px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #moveCounter {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #controls {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            opacity: 0.7;
            text-shadow: 0 0 5px #00ffff;
            text-align: center;
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            text-shadow: 0 0 30px #39ff14;
            color: #39ff14;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #message.show {
            opacity: 1;
        }
        
        #message.death {
            color: #dc143c;
            text-shadow: 0 0 30px #dc143c;
        }

        /* Scanline effect */
        canvas::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="levelInfo">Level 1 / 5</div>
            <div id="moveCounter">Moves: 0</div>
            <div id="controls">WASD/Arrows: Move | Space: Clone | R: Restart | Shift: Show Path</div>
            <div id="message">LEVEL COMPLETE!</div>
        </div>
    </div>

    <script>
        // ========== CANVAS SETUP ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 45;
        const GRID_WIDTH = 16;
        const GRID_HEIGHT = 12;
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;

        // ========== TILE TYPES ==========
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            SPIKE: 2,
            PLATE: 3,
            GATE: 4,
            EXIT: 5
        };

        // ========== DIRECTIONS ==========
        const DIRS = {
            UP: 0,
            RIGHT: 1,
            DOWN: 2,
            LEFT: 3
        };

        const DIR_VECTORS = [
            {x: 0, y: -1}, // UP
            {x: 1, y: 0},  // RIGHT
            {x: 0, y: 1},  // DOWN
            {x: -1, y: 0}  // LEFT
        ];

        // ========== LEVEL DATA ==========
        const levels = [
            {
                name: "Tutorial",
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                    [1,0,0,0,3,0,0,1,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,1,0,0,0,4,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                playerStart: {x: 1, y: 1},
                cloneSpeed: 500,
                cloneLifespan: 10000,
                gates: [{plate: {x: 4, y: 5}, gate: {x: 11, y: 6}}]
            },
            {
                name: "Herding",
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],
                    [1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1],
                    [1,0,1,0,3,0,1,0,0,0,0,0,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1],
                    [1,0,1,1,1,1,1,1,0,0,0,0,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,4,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                playerStart: {x: 2, y: 1},
                cloneSpeed: 500,
                cloneLifespan: 12000,
                gates: [{plate: {x: 4, y: 4}, gate: {x: 11, y: 8}}]
            },
            {
                name: "Spike Cross",
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1],
                    [1,0,0,0,1,0,0,0,0,3,1,0,0,0,0,1],
                    [1,0,0,0,1,0,2,2,2,0,1,0,0,0,0,1],
                    [1,0,0,0,1,0,2,2,2,0,0,0,0,0,0,1],
                    [1,0,0,0,1,0,2,2,2,0,0,0,0,0,0,1],
                    [1,0,0,0,1,1,1,1,1,1,1,1,4,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                playerStart: {x: 1, y: 1},
                cloneSpeed: 450,
                cloneLifespan: 10000,
                gates: [{plate: {x: 9, y: 4}, gate: {x: 12, y: 8}}]
            },
            {
                name: "Timing",
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,4,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,3,0,1,1,1,1,0,2,0,1,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,2,0,1,0,1],
                    [1,0,1,1,1,1,1,0,0,0,0,2,0,1,0,1],
                    [1,0,0,0,0,0,0,0,3,0,4,0,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                playerStart: {x: 1, y: 1},
                cloneSpeed: 400,
                cloneLifespan: 14000,
                gates: [
                    {plate: {x: 4, y: 4}, gate: {x: 7, y: 1}},
                    {plate: {x: 8, y: 7}, gate: {x: 10, y: 7}}
                ]
            },
            {
                name: "Complex Maze",
                grid: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1],
                    [1,0,0,1,0,1,1,1,1,0,1,0,1,1,0,1],
                    [1,0,0,0,0,1,0,3,0,0,0,0,0,1,0,1],
                    [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                    [1,0,1,1,1,1,1,0,2,2,2,1,1,1,0,1],
                    [1,0,1,0,0,0,1,0,2,2,2,0,0,0,0,1],
                    [1,0,0,0,3,0,0,0,2,2,2,0,1,1,4,1],
                    [1,0,1,1,1,1,1,1,1,1,0,0,0,0,5,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                playerStart: {x: 1, y: 1},
                cloneSpeed: 350,
                cloneLifespan: 16000,
                gates: [
                    {plate: {x: 7, y: 3}, gate: {x: 14, y: 8}},
                    {plate: {x: 4, y: 8}, gate: {x: 14, y: 8}}
                ]
            }
        ];

        // ========== GAME STATE ==========
        let currentLevel = 0;
        let grid = [];
        let player = {x: 0, y: 0, targetX: 0, targetY: 0, moving: false, progress: 0};
        let clone = null;
        let keys = {};
        let moveCount = 0;
        let showPath = false;
        let particles = [];
        let screenShake = 0;
        let flashAlpha = 0;
        let flashColor = '#39ff14';

        // ========== CLONE LOGIC ==========
        class Clone {
            constructor(x, y, dir, speed, lifespan) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.direction = dir;
                this.speed = speed;
                this.lifespan = lifespan;
                this.age = 0;
                this.moving = false;
                this.progress = 0;
                this.moveTimer = 0;
                this.alive = true;
            }

            update(dt) {
                if (!this.alive) return;

                this.age += dt;
                if (this.age >= this.lifespan) {
                    this.expire();
                    return;
                }

                // Handle movement animation
                if (this.moving) {
                    this.progress += dt / 250;
                    if (this.progress >= 1) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.moving = false;
                        this.progress = 0;
                    }
                } else {
                    // Autonomous movement tick
                    this.moveTimer += dt;
                    if (this.moveTimer >= this.speed) {
                        this.moveTimer = 0;
                        this.attemptMove();
                    }
                }
            }

            attemptMove() {
                // Try to move in current direction
                const vec = DIR_VECTORS[this.direction];
                const nextX = this.x + vec.x;
                const nextY = this.y + vec.y;

                if (this.canMove(nextX, nextY)) {
                    this.targetX = nextX;
                    this.targetY = nextY;
                    this.moving = true;
                    this.progress = 0;
                } else {
                    // Turn clockwise
                    this.direction = (this.direction + 1) % 4;
                }
            }

            canMove(x, y) {
                // Check bounds
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return false;
                
                // Check wall
                if (grid[y][x] === TILES.WALL) return false;
                
                // Check closed gate
                const level = levels[currentLevel];
                for (const gateData of level.gates) {
                    if (gateData.gate.x === x && gateData.gate.y === y) {
                        const platePressed = isPlatePressed(gateData.plate);
                        if (!platePressed) return false;
                    }
                }
                
                // Check if player is blocking
                if (player.x === x && player.y === y) return false;
                
                return true;
            }

            expire() {
                this.alive = false;
                // Spawn particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: (this.x + 0.5) * TILE_SIZE,
                        y: (this.y + 0.5) * TILE_SIZE,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 1,
                        color: '#ff0080'
                    });
                }
            }

            getRenderPos() {
                if (this.moving) {
                    const startX = (this.x + 0.5) * TILE_SIZE;
                    const startY = (this.y + 0.5) * TILE_SIZE;
                    const endX = (this.targetX + 0.5) * TILE_SIZE;
                    const endY = (this.targetY + 0.5) * TILE_SIZE;
                    const t = easeInOutQuad(this.progress);
                    return {
                        x: startX + (endX - startX) * t,
                        y: startY + (endY - startY) * t
                    };
                }
                return {
                    x: (this.x + 0.5) * TILE_SIZE,
                    y: (this.y + 0.5) * TILE_SIZE
                };
            }
        }

        // ========== HELPER FUNCTIONS ==========
        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function isPlatePressed(plate) {
            if (player.x === plate.x && player.y === plate.y) return true;
            if (clone && clone.alive && clone.x === plate.x && clone.y === plate.y) return true;
            return false;
        }

        function canPlayerMove(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return false;
            if (grid[y][x] === TILES.WALL) return false;
            if (grid[y][x] === TILES.SPIKE) return false;
            
            const level = levels[currentLevel];
            for (const gateData of level.gates) {
                if (gateData.gate.x === x && gateData.gate.y === y) {
                    if (!isPlatePressed(gateData.plate)) return false;
                }
            }
            return true;
        }

        function spawnClone() {
            const dir = DIRS.RIGHT; // Default starting direction
            clone = new Clone(
                player.x,
                player.y,
                dir,
                levels[currentLevel].cloneSpeed,
                levels[currentLevel].cloneLifespan
            );
            
            // Spawn particles
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: (player.x + 0.5) * TILE_SIZE,
                    y: (player.y + 0.5) * TILE_SIZE,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 1,
                    color: '#ff0080'
                });
            }
        }

        function predictClonePath() {
            if (!clone || !clone.alive) return [];
            
            const path = [];
            let testClone = {
                x: clone.x,
                y: clone.y,
                direction: clone.direction
            };
            
            for (let i = 0; i < 8; i++) {
                const vec = DIR_VECTORS[testClone.direction];
                const nextX = testClone.x + vec.x;
                const nextY = testClone.y + vec.y;
                
                if (testClone.x >= 0 && testClone.x < GRID_WIDTH && 
                    testClone.y >= 0 && testClone.y < GRID_HEIGHT) {
                    path.push({
                        x: testClone.x,
                        y: testClone.y,
                        dir: testClone.direction
                    });
                }
                
                if (nextX >= 0 && nextX < GRID_WIDTH && nextY >= 0 && nextY < GRID_HEIGHT &&
                    grid[nextY][nextX] !== TILES.WALL &&
                    !(player.x === nextX && player.y === nextY)) {
                    testClone.x = nextX;
                    testClone.y = nextY;
                } else {
                    testClone.direction = (testClone.direction + 1) % 4;
                }
            }
            
            return path;
        }

        // ========== INPUT HANDLING ==========
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                spawnClone();
            }
            
            if (e.key === 'r' || e.key === 'R') {
                restartLevel();
            }
            
            if (e.key === 'Shift') {
                showPath = true;
            }
            
            if (!player.moving) {
                let moved = false;
                if (keys['ArrowUp'] || keys['w']) {
                    if (canPlayerMove(player.x, player.y - 1)) {
                        player.targetY = player.y - 1;
                        player.moving = true;
                        moved = true;
                    }
                } else if (keys['ArrowDown'] || keys['s']) {
                    if (canPlayerMove(player.x, player.y + 1)) {
                        player.targetY = player.y + 1;
                        player.moving = true;
                        moved = true;
                    }
                } else if (keys['ArrowLeft'] || keys['a']) {
                    if (canPlayerMove(player.x - 1, player.y)) {
                        player.targetX = player.x - 1;
                        player.moving = true;
                        moved = true;
                    }
                } else if (keys['ArrowRight'] || keys['d']) {
                    if (canPlayerMove(player.x + 1, player.y)) {
                        player.targetX = player.x + 1;
                        player.moving = true;
                        moved = true;
                    }
                }
                if (moved) moveCount++;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === 'Shift') {
                showPath = false;
            }
        });

        // ========== GAME LOGIC ==========
        function updatePlayer(dt) {
            if (player.moving) {
                player.progress += dt / 250;
                if (player.progress >= 1) {
                    player.x = player.targetX;
                    player.y = player.targetY;
                    player.moving = false;
                    player.progress = 0;
                    
                    // Check exit
                    if (grid[player.y][player.x] === TILES.EXIT) {
                        levelComplete();
                    }
                }
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= dt / 1000;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function levelComplete() {
            flashColor = '#39ff14';
            flashAlpha = 0.5;
            document.getElementById('message').classList.add('show');
            document.getElementById('message').classList.remove('death');
            
            setTimeout(() => {
                document.getElementById('message').classList.remove('show');
                currentLevel++;
                if (currentLevel >= levels.length) {
                    currentLevel = 0;
                    document.getElementById('message').textContent = 'ALL LEVELS COMPLETE!';
                    document.getElementById('message').classList.add('show');
                }
                initLevel();
            }, 2000);
        }

        function restartLevel() {
            initLevel();
        }

        function initLevel() {
            const level = levels[currentLevel];
            grid = level.grid.map(row => [...row]);
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.targetX = player.x;
            player.targetY = player.y;
            player.moving = false;
            player.progress = 0;
            clone = null;
            moveCount = 0;
            particles = [];
            
            document.getElementById('levelInfo').textContent = `Level ${currentLevel + 1} / ${levels.length}`;
            document.getElementById('moveCounter').textContent = `Moves: ${moveCount}`;
            document.getElementById('message').textContent = 'LEVEL COMPLETE!';
        }

        // ========== RENDERING ==========
        function render() {
            // Screen shake
            ctx.save();
            if (screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake,
                    (Math.random() - 0.5) * screenShake
                );
                screenShake *= 0.9;
            }

            // Clear
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * TILE_SIZE, 0);
                ctx.lineTo(x * TILE_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * TILE_SIZE);
                ctx.lineTo(canvas.width, y * TILE_SIZE);
                ctx.stroke();
            }

            // Draw tiles
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tile = grid[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    switch (tile) {
                        case TILES.WALL:
                            ctx.fillStyle = '#1a1a2e';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#00ffff';
                            ctx.strokeRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                            ctx.shadowBlur = 0;
                            break;
                        
                        case TILES.SPIKE:
                            const spikeTime = Date.now() / 1000;
                            const breathe = Math.sin(spikeTime * 2) * 0.1 + 0.9;
                            ctx.fillStyle = `rgba(220, 20, 60, ${breathe})`;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#dc143c';
                            for (let i = 0; i < 5; i++) {
                                ctx.beginPath();
                                const sx = px + (i / 4) * TILE_SIZE;
                                ctx.moveTo(sx, py + TILE_SIZE);
                                ctx.lineTo(sx + TILE_SIZE / 8, py + TILE_SIZE / 3);
                                ctx.lineTo(sx + TILE_SIZE / 4, py + TILE_SIZE);
                                ctx.fill();
                            }
                            ctx.shadowBlur = 0;
                            break;
                        
                        case TILES.PLATE:
                            const pressed = isPlatePressed({x, y});
                            const pulseTime = Date.now() / 300;
                            const pulse = Math.sin(pulseTime) * 0.2 + 0.8;
                            ctx.fillStyle = pressed ? 'rgba(255, 165, 0, 0.8)' : 'rgba(255, 165, 0, 0.3)';
                            ctx.shadowBlur = pressed ? 20 : 10;
                            ctx.shadowColor = '#ffa500';
                            ctx.beginPath();
                            ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, TILE_SIZE / 3 * pulse, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            break;
                        
                        case TILES.GATE:
                            const gateOpen = levels[currentLevel].gates.some(g => 
                                g.gate.x === x && g.gate.y === y && isPlatePressed(g.plate)
                            );
                            if (!gateOpen) {
                                ctx.strokeStyle = '#b026ff';
                                ctx.lineWidth = 3;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = '#b026ff';
                                for (let i = 0; i < 5; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(px + TILE_SIZE / 2, py + i * TILE_SIZE / 4);
                                    ctx.lineTo(px + TILE_SIZE / 2, py + (i + 0.7) * TILE_SIZE / 4);
                                    ctx.stroke();
                                }
                                ctx.shadowBlur = 0;
                            }
                            break;
                        
                        case TILES.EXIT:
                            const exitPulse = Math.sin(Date.now() / 400) * 0.3 + 0.7;
                            const grad = ctx.createRadialGradient(
                                px + TILE_SIZE / 2, py + TILE_SIZE / 2, 0,
                                px + TILE_SIZE / 2, py + TILE_SIZE / 2, TILE_SIZE / 2
                            );
                            grad.addColorStop(0, 'rgba(57, 255, 20, 0.8)');
                            grad.addColorStop(1, 'rgba(57, 255, 20, 0)');
                            ctx.fillStyle = grad;
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            
                            ctx.fillStyle = '#39ff14';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#39ff14';
                            ctx.fillRect(
                                px + TILE_SIZE / 2 - 10 * exitPulse,
                                py + TILE_SIZE / 2 - 10 * exitPulse,
                                20 * exitPulse,
                                20 * exitPulse
                            );
                            ctx.shadowBlur = 0;
                            break;
                    }
                }
            }

            // Draw path prediction
            if (showPath && clone && clone.alive) {
                const path = predictClonePath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                for (let i = 0; i < path.length; i++) {
                    const p = path[i];
                    const px = (p.x + 0.5) * TILE_SIZE;
                    const py = (p.y + 0.5) * TILE_SIZE;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            });
            ctx.globalAlpha = 1;

            // Draw player
            const playerPos = player.moving ? {
                x: ((player.x + 0.5) + (player.targetX - player.x) * easeInOutQuad(player.progress)) * TILE_SIZE,
                y: ((player.y + 0.5) + (player.targetY - player.y) * easeInOutQuad(player.progress)) * TILE_SIZE
            } : {
                x: (player.x + 0.5) * TILE_SIZE,
                y: (player.y + 0.5) * TILE_SIZE
            };

            const playerGrad = ctx.createRadialGradient(playerPos.x, playerPos.y, 0, playerPos.x, playerPos.y, 15);
            playerGrad.addColorStop(0, '#ffffff');
            playerGrad.addColorStop(0.6, '#00d9ff');
            playerGrad.addColorStop(1, 'rgba(0, 217, 255, 0)');
            ctx.fillStyle = playerGrad;
            ctx.beginPath();
            ctx.arc(playerPos.x, playerPos.y, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#00d9ff';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00d9ff';
            ctx.beginPath();
            ctx.arc(playerPos.x, playerPos.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw clone
            if (clone && clone.alive) {
                const clonePos = clone.getRenderPos();
                const flicker = clone.age > clone.lifespan - 2000 ? Math.random() * 0.3 + 0.7 : 1;
                
                ctx.globalAlpha = 0.6 * flicker;
                const cloneGrad = ctx.createRadialGradient(clonePos.x, clonePos.y, 0, clonePos.x, clonePos.y, 15);
                cloneGrad.addColorStop(0, '#ff0080');
                cloneGrad.addColorStop(1, 'rgba(255, 0, 128, 0)');
                ctx.fillStyle = cloneGrad;
                ctx.beginPath();
                ctx.arc(clonePos.x, clonePos.y, 15, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ff0080';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0080';
                ctx.beginPath();
                ctx.arc(clonePos.x, clonePos.y, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                // Draw timer bar
                const timeLeft = 1 - (clone.age / clone.lifespan);
                const barWidth = 30;
                const barHeight = 4;
                const barX = clonePos.x - barWidth / 2;
                const barY = clonePos.y - 25;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                let barColor = '#39ff14';
                if (timeLeft < 0.3) barColor = '#dc143c';
                else if (timeLeft < 0.6) barColor = '#ffa500';
                
                ctx.fillStyle = barColor;
                ctx.fillRect(barX, barY, barWidth * timeLeft, barHeight);
            }

            // Flash effect
            if (flashAlpha > 0) {
                ctx.fillStyle = flashColor;
                ctx.globalAlpha = flashAlpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
                flashAlpha *= 0.9;
            }

            ctx.restore();

            // Scanline effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            for (let y = 0; y < canvas.height; y += 2) {
                ctx.fillRect(0, y, canvas.width, 1);
            }
        }

        // ========== GAME LOOP ==========
        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const dt = now - lastTime;
            lastTime = now;

            updatePlayer(dt);
            if (clone) clone.update(dt);
            updateParticles(dt);
            
            render();
            
            document.getElementById('moveCounter').textContent = `Moves: ${moveCount}`;
            
            requestAnimationFrame(gameLoop);
        }

        // ========== START GAME ==========
        initLevel();
        gameLoop();
    </script>
</body>
</html>