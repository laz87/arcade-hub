<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spike dodge</title>
    <style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background: #050c1a; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            overflow: hidden;
            touch-action: none;
        }
  /*the button styling*/
            #muteBtn {
        position: absolute;
        top: 15px;
        right: 20px;
        background: rgba(255, 77, 148, 0.9);
        color: white;
        border: 3px solid white;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        pointer-events: auto;
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #muteBtn:hover {
        background: rgba(255, 77, 148, 1);
        transform: scale(1.1);
    }

    #muteBtn:active {
        transform: scale(0.95);
    }

    #muteBtn.muted {
        background: rgba(100, 100, 100, 0.9);
    }

        #gameContainer { 
            position: relative; 
            border: 10px solid #ff4d94; 
            border-radius: 15px; 
            box-shadow: 0 0 50px rgba(0,0,0,0.7); 
            max-width: 100vw;
            max-height: 100vh;
        }
        canvas { 
            display: block; 
            background: #4cc9f0; 
            cursor: crosshair; 
            max-width: 100%;
            height: auto;
        }
        #ui { 
    position: absolute; 
    top: 20px; 
    width: 100%; 
    text-align: center; 
    color: #fff; 
    font-size: 20px; 
    font-weight: bold; 
    text-shadow: 
        3px 3px 0 #ff4d94,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
    pointer-events: none;
    letter-spacing: 2px;
    animation: floatText 3s ease-in-out infinite;
    background: linear-gradient(135deg, rgba(255, 77, 148, 0.3) 0%, rgba(76, 201, 240, 0.3) 100%);
    backdrop-filter: blur(8px);
    padding: 12px 20px;
    border-radius: 50px;
    border: 3px solid rgba(255, 255, 255, 0.5);
    box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.3),
        inset 0 2px 5px rgba(255, 255, 255, 0.3);
    display: inline-block;
    left: 50%;
    transform: translateX(-50%);
    width: auto;
    max-width: 90%;
}

@keyframes floatText {
    0%, 100% { transform: translateX(-50%) translateY(0px); }
    50% { transform: translateX(-50%) translateY(-5px); }
}

#lvlDisplay { position: absolute; top: 15px; left: 20px; color: #fff; font-size: 24px; text-shadow: 2px 2px #000; pointer-events: none; }

    </style>
</head>
<body>

    <div id="ui">TAP BLOCKS | SWIPE UP TO JUMP</div>

<div id="gameContainer">
    <button id="muteBtn" title="Toggle Sound">ðŸ”Š</button>
     <div id="lvlDisplay">Level: 1</div>
    <canvas id="gameCanvas" width="960" height="640"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRID = 80;
const ROWS = 8;
const COLS = 12;

let blocks = [];
let gameState = 'PLAYING';
let portalPulse = 0;
let currentLevel = 1;

let bun = {
    x: GRID * 0.5 + 40,
    y: GRID * 3.5,
    radius: 28,
    vx: 1.3,
    vy: 0,
    rotation: 0
};

const portal = { x: GRID * 11.5, y: GRID * 4.5, radius: 35 };

// Mobile Touch Variables
let touchStartX = 0;
let touchStartY = 0;

// --- AUDIO SYSTEM ---
let audioCtx = null;
let musicGainNode = null;
let sfxGainNode = null;
let audioInitialized = false;
let musicInterval = null;
let isMuted = false;

// Initialize audio on first user interaction
function initAudio() {
    if (audioInitialized) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create gain nodes for volume control
    musicGainNode = audioCtx.createGain();
    musicGainNode.connect(audioCtx.destination);
    musicGainNode.gain.value = 0.25; // Music volume (25%)
    
    sfxGainNode = audioCtx.createGain();
    sfxGainNode.connect(audioCtx.destination);
    sfxGainNode.gain.value = 0.4; // SFX volume (40%)
    
    audioInitialized = true;
    playBackgroundMusic();
}

// Toggle mute function
function toggleMute() {
    isMuted = !isMuted;
    const muteBtn = document.getElementById('muteBtn');
    
    if (isMuted) {
        // Mute all audio
        if (musicGainNode) musicGainNode.gain.value = 0;
        if (sfxGainNode) sfxGainNode.gain.value = 0;
        muteBtn.textContent = 'ðŸ”‡';
        muteBtn.classList.add('muted');
        muteBtn.title = 'Unmute Sound';
    } else {
        // Unmute audio
        if (musicGainNode) musicGainNode.gain.value = 0.25;
        if (sfxGainNode) sfxGainNode.gain.value = 0.4;
        muteBtn.textContent = 'ðŸ”Š';
        muteBtn.classList.remove('muted');
        muteBtn.title = 'Mute Sound';
    }
}

// Adventure Time style background music
function playBackgroundMusic() {
    if (!audioCtx || !musicGainNode) return;
    
    // Upbeat melody pattern
    const melody = [
        { freq: 523.25, duration: 0.2 }, // C5
        { freq: 587.33, duration: 0.2 }, // D5
        { freq: 659.25, duration: 0.2 }, // E5
        { freq: 783.99, duration: 0.3 }, // G5
        { freq: 659.25, duration: 0.2 }, // E5
        { freq: 587.33, duration: 0.2 }, // D5
        { freq: 523.25, duration: 0.4 }, // C5
        { freq: 587.33, duration: 0.2 }, // D5
        { freq: 659.25, duration: 0.2 }, // E5
        { freq: 523.25, duration: 0.4 }  // C5
    ];
    
    let noteIndex = 0;
    
    function playNote() {
        if (!audioCtx || gameState === 'FAIL') return;
        
        const note = melody[noteIndex];
        const osc = audioCtx.createOscillator();
        const noteGain = audioCtx.createGain();
        
        osc.type = 'triangle';
        osc.frequency.value = note.freq;
        
        osc.connect(noteGain);
        noteGain.connect(musicGainNode);
        
        noteGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        noteGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + note.duration);
        
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + note.duration);
        
        noteIndex = (noteIndex + 1) % melody.length;
        
        if (musicInterval) clearTimeout(musicInterval);
        musicInterval = setTimeout(playNote, note.duration * 1000);
    }
    
    playNote();
}

// Block break sound
function playBlockBreakSound() {
    if (!audioCtx) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(sfxGainNode);
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(300, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
    
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.1);
}

// Jump sound
function playJumpSound() {
    if (!audioCtx) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(sfxGainNode);
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);
    
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
    
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.15);
}

// Roll/Movement sound (subtle)
function playRollSound() {
    if (!audioCtx || Math.random() > 0.3) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(sfxGainNode);
    
    osc.type = 'sine';
    osc.frequency.value = 100 + Math.random() * 50;
    
    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
    
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.05);
}

// Spike hit sound
function playSpikeHitSound() {
    if (!audioCtx) return;
    
    for (let i = 0; i < 2; i++) {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.type = 'sawtooth';
            osc.frequency.value = 200 - (i * 50);
            
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.2);
        }, i * 50);
    }
}

// Portal enter/victory sound
function playVictorySound() {
    if (!audioCtx) return;
    
    const frequencies = [523.25, 659.25, 783.99, 1046.50];
    
    frequencies.forEach((freq, i) => {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.5);
        }, i * 80);
    });
}

// Fail/Death sound
function playFailSound() {
    if (!audioCtx) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(sfxGainNode);
    
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
    
    gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
    
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.5);
}

// Level complete sound
function playLevelCompleteSound() {
    if (!audioCtx) return;
    
    const notes = [659.25, 783.99, 1046.50];
    
    notes.forEach((freq, i) => {
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.type = 'triangle';
            osc.frequency.value = freq;
            
            gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.3);
        }, i * 100);
    });
}

function initLevel() {
    blocks = [];
    document.getElementById('lvlDisplay').innerText = `Level: ${currentLevel}`;
    const colors = ['#ffffff', '#e1f5fe', '#b3e5fc', '#81d4fa'];
    
    const safeRow = Math.floor(Math.random() * 3) + 3; 
    
    const emptySlots = [
        {r: 3, c: 0}, {r: 3, c: 1}, {r: 4, c: 11}, {r: 5, c: 11}
    ];

    let spikeChance = Math.min(0.05 + (currentLevel * 0.01), 0.20);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const isEmpty = emptySlots.some(slot => slot.r === r && slot.c === c);
            if (isEmpty) continue;

            let type = 'ice';
            if (r !== safeRow && c > 1 && c < 10) {
                if (Math.random() < spikeChance) {
                    type = 'spike';
                }
            }

            blocks.push({
                x: c * GRID,
                y: r * GRID,
                color: colors[Math.floor(Math.random() * colors.length)],
                active: true,
                type: type
            });
        }
    }
}

function update() {
    if (gameState !== 'PLAYING') return;
    portalPulse += 0.05;

    let onGround = false;
    let blocked = false;

    if (bun.y > canvas.height + 50 || bun.x > canvas.width + 50 || bun.x < -50) {
        return fail("The Bun disappeared!");
    }

    blocks.forEach(b => {
        if (!b.active) return;
        const bx = b.x, by = b.y;
        
        if (bun.x + 15 > bx && bun.x - 15 < bx + GRID) {
            if (bun.y + bun.radius > by && bun.y + bun.radius < by + 25) {
                if (b.type === 'spike') {
                    playSpikeHitSound();
                    return fail("POKE! You hit a spike!");
                }
                onGround = true;
                bun.vy = 0;
                bun.y = by - bun.radius;
            }
        }

        if (bun.y + 10 > by && bun.y - 10 < by + GRID) {
            if (bun.x + bun.radius > bx && bun.x + bun.radius < bx + 15) {
                if (b.type === 'spike') {
                    playSpikeHitSound();
                    return fail("OUCH! Spikes are dangerous!");
                }
                blocked = true;
            }
        }
    });

    if (!onGround) bun.vy += 0.45;
    bun.y += bun.vy;

    if (!blocked) {
        bun.x += bun.vx;
        bun.rotation += 0.08;
        playRollSound();
    }

    if (Math.hypot(bun.x - portal.x, bun.y - portal.y) < 40) {
        playVictorySound();
        playLevelCompleteSound();
        currentLevel++;
        bun.vx += 0.1;
        alert(`Victory! Moving to Level ${currentLevel}`);
        reset();
    }
}

function drawBackground() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            ctx.fillStyle = (r + c) % 2 === 0 ? '#4cc9f0' : '#48bfe3';
            ctx.fillRect(c * GRID, r * GRID, GRID, GRID);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.strokeRect(c * GRID, r * GRID, GRID, GRID);
        }
    }
}

function draw() {
    drawBackground();

    blocks.forEach(b => {
        if (!b.active) return;
        if (b.type === 'ice') {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x + 2, b.y + 2, GRID - 4, GRID - 4);
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath();
            ctx.moveTo(b.x + 10, b.y + 10); ctx.lineTo(b.x + 30, b.y + 15);
            ctx.stroke();
        } else {
            ctx.fillStyle = '#ff5252';
            ctx.fillRect(b.x + 2, b.y + 2, GRID - 4, GRID - 4);
            ctx.fillStyle = '#b71c1c';
            for(let i=0; i<3; i++) {
                ctx.beginPath();
                ctx.moveTo(b.x + 15 + i*25, b.y + GRID - 5);
                ctx.lineTo(b.x + 27 + i*25, b.y + 15);
                ctx.lineTo(b.x + 40 + i*25, b.y + GRID - 5);
                ctx.fill();
            }
        }
    });

    const pSize = 30 + Math.sin(portalPulse) * 5;
    ctx.shadowBlur = 20; ctx.shadowColor = "#00ffff";
    ctx.fillStyle = "white";
    ctx.beginPath(); ctx.arc(portal.x, portal.y, pSize, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;

    ctx.save();
    ctx.translate(bun.x, bun.y);
    ctx.rotate(bun.rotation);
    ctx.fillStyle = "#e6b38a";
    ctx.beginPath(); ctx.arc(0, 0, bun.radius, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#8b5a2b"; ctx.lineWidth = 3; ctx.stroke();
    ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*1.2); ctx.stroke();
    ctx.restore();

    update();
    requestAnimationFrame(draw);
}

function fail(msg) {
    gameState = 'FAIL';
    playFailSound();
    alert(msg);
    currentLevel = 1;
    bun.vx = 1.3;
    reset();
}

function reset() {
    bun.x = GRID * 0.5 + 40; bun.y = GRID * 3.5;
    bun.vy = 0;
    gameState = 'PLAYING';
    initLevel();
}

// Unified Interaction Logic
function handleInput(x, y, isSwipe = false) {
    if (!audioInitialized) {
        initAudio();
    }
    
    if (isSwipe) {
        if (bun.vy === 0) {
            bun.vy = -11;
            playJumpSound();
        }
    } else {
        blocks.forEach(b => {
            if (x > b.x && x < b.x + GRID && y > b.y && y < b.y + GRID) {
                if (b.type === 'ice' && b.active) {
                    b.active = false;
                    playBlockBreakSound();
                }
            }
        });
    }
}

// Mouse Support
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;

    if (Math.hypot(mx - bun.x, my - bun.y) < bun.radius + 20) {
        handleInput(mx, my, true);
    } else {
        handleInput(mx, my, false);
    }
});

// Touch Support (Mobile/Tablet)
canvas.addEventListener('touchstart', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    touchStartX = (e.touches[0].clientX - rect.left) * scaleX;
    touchStartY = (e.touches[0].clientY - rect.top) * scaleY;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const touchEndX = (e.changedTouches[0].clientX - rect.left) * scaleX;
    const touchEndY = (e.changedTouches[0].clientY - rect.top) * scaleY;

    const swipeDistance = touchStartY - touchEndY;

    if (swipeDistance > 30) {
        handleInput(0, 0, true);
    } else {
        handleInput(touchEndX, touchEndY, false);
    }
}, { passive: false });

initLevel();
draw();

// Mute button event listener
document.getElementById('muteBtn').addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent the click from affecting the game
    toggleMute();
});
</script>
</body>
</html>