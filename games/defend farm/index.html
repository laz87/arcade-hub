<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Fang Gang</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #1a472a 0%, #2d5a3d 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Impact', 'Arial Black', sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
            border: 8px solid #8B4513;
            border-radius: 10px;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            text-align: center;
        }
        .title {
            font-size: 72px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B4513, 8px 8px 0 #000;
            margin-bottom: 20px;
            letter-spacing: 4px;
        }
        .subtitle {
            font-size: 32px;
            color: #90EE90;
            margin-bottom: 40px;
            text-shadow: 2px 2px 0 #000;
        }
        .button {
            padding: 20px 60px;
            font-size: 28px;
            font-family: inherit;
            background: #FFD700;
            color: #000;
            border: 4px solid #8B4513;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: none;
            margin: 10px;
        }
        .button:hover {
            background: #FFA500;
            transform: scale(1.1);
        }
        .controls {
            font-size: 18px;
            color: #ccc;
            margin-top: 30px;
            line-height: 1.8;
        }
        .stats {
            font-size: 24px;
            color: #FFD700;
            margin: 10px 0;
            text-shadow: 2px 2px 0 #000;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="startScreen">
            <div class="title">THE FANG GANG</div>
            <div class="subtitle">Defend the Farm!</div>
            <button class="button" onclick="startGame()">PLAY GAME</button>
            <div class="controls">
                WASD/Arrows = Move<br>
                Mouse = Aim<br>
                Click = Shoot
            </div>
        </div>
        <div id="gameOverScreen" class="hidden">
            <div class="title" style="font-size: 64px;">GAME OVER</div>
            <div class="stats" id="finalStats"></div>
            <button class="button" onclick="restartGame()">RESTART</button>
            <button class="button" onclick="toMainMenu()">MAIN MENU</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1200;
        canvas.height = 800;
        
        const ARENA_PADDING = 50;
        const ARENA_BOUNDS = {
            left: ARENA_PADDING,
            right: canvas.width - ARENA_PADDING,
            top: ARENA_PADDING,
            bottom: canvas.height - ARENA_PADDING
        };

        // Audio Context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(freq, endFreq, duration, type = 'sine') {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if (endFreq) {
                osc.frequency.linearRampToValueAtTime(endFreq, audioCtx.currentTime + duration);
            }
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // Game state
        const game = {
            state: 'menu',
            score: 0,
            wave: 1,
            shield: 100,
            kills: 0,
            startTime: 0,
            invincible: false,
            invincibleEnd: 0,
            waveTransition: false,
            waveTransitionEnd: 0,
            shake: 0,
            flash: 0
        };

        // Particle class
        class Particle {
            constructor(x, y, color, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.size = Math.random() * 4 + 2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2; // gravity
                this.life -= 0.02;
                return this.life > 0;
            }
            
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.size = 30;
                this.speed = 4;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.lastShot = 0;
                this.fireRate = 100;
            }
            
            update(keys, mouseX, mouseY) {
                // Movement
                let dx = 0;
                let dy = 0;
                if (keys['w'] || keys['ArrowUp']) dy -= 1;
                if (keys['s'] || keys['ArrowDown']) dy += 1;
                if (keys['a'] || keys['ArrowLeft']) dx -= 1;
                if (keys['d'] || keys['ArrowRight']) dx += 1;
                
                // Normalize diagonal
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.vx = dx * this.speed;
                this.vy = dy * this.speed;
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundaries
                this.x = Math.max(ARENA_BOUNDS.left + this.size, Math.min(ARENA_BOUNDS.right - this.size, this.x));
                this.y = Math.max(ARENA_BOUNDS.top + this.size, Math.min(ARENA_BOUNDS.bottom - this.size, this.y));
                
                // Rotation
                this.angle = Math.atan2(mouseY - this.y, mouseX - this.x);
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Body (brown rectangle)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-this.size, -this.size * 0.8, this.size * 2, this.size * 1.6);
                
                // LEGO texture
                ctx.fillStyle = '#654321';
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 2; j++) {
                        ctx.fillRect(-this.size + i * 12 + 4, -this.size * 0.6 + j * 16, 8, 8);
                    }
                }
                
                // Eye
                ctx.fillStyle = '#FFF';
                ctx.fillRect(this.size * 0.3, -8, 12, 12);
                ctx.fillStyle = '#000';
                ctx.fillRect(this.size * 0.3 + 3, -5, 6, 6);
                
                // Teeth
                ctx.fillStyle = '#FFF';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size + i * 15, this.size * 0.8);
                    ctx.lineTo(-this.size + i * 15 + 7, this.size * 0.8 - 10);
                    ctx.lineTo(-this.size + i * 15 + 14, this.size * 0.8);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            shoot(mouseX, mouseY) {
                const now = Date.now();
                if (now - this.lastShot < this.fireRate) return;
                this.lastShot = now;
                
                const weaponLevel = Math.floor((game.wave - 1) / 2) + 1;
                const angle = Math.atan2(mouseY - this.y, mouseX - this.x);
                
                if (weaponLevel === 1) {
                    projectiles.push(new Projectile(this.x, this.y, angle));
                } else if (weaponLevel === 2) {
                    projectiles.push(new Projectile(this.x, this.y - 10, angle));
                    projectiles.push(new Projectile(this.x, this.y + 10, angle));
                } else if (weaponLevel === 3) {
                    projectiles.push(new Projectile(this.x, this.y, angle));
                    projectiles.push(new Projectile(this.x, this.y, angle - 0.26));
                    projectiles.push(new Projectile(this.x, this.y, angle + 0.26));
                } else if (weaponLevel === 4) {
                    for (let i = -1; i <= 1; i++) {
                        projectiles.push(new Projectile(this.x, this.y, angle + i * 0.26));
                    }
                    projectiles.push(new Projectile(this.x, this.y, angle + 0.52));
                } else {
                    for (let i = -2; i <= 2; i++) {
                        projectiles.push(new Projectile(this.x, this.y, angle + i * 0.39));
                    }
                }
                
                playSound(200, 180, 0.1, 'square');
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.radius = 8;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                return this.x > 0 && this.x < canvas.width && this.y > 0 && this.y < canvas.height;
            }
            
            draw() {
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(this.x - 2, this.y - 2, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Nixel class
        class Nixel {
            constructor() {
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { // top
                    this.x = Math.random() * canvas.width;
                    this.y = -50;
                } else if (side === 1) { // right
                    this.x = canvas.width + 50;
                    this.y = Math.random() * canvas.height;
                } else if (side === 2) { // bottom
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height + 50;
                } else { // left
                    this.x = -50;
                    this.y = Math.random() * canvas.height;
                }
                
                this.radius = 20;
                this.speed = 1.5 + (game.wave - 1) * 0.1;
                this.speed = Math.min(this.speed, 4);
                this.bounceOffset = Math.random() * Math.PI * 2;
            }
            
            update(playerX, playerY) {
                const angle = Math.atan2(playerY - this.y, playerX - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
                this.bounceOffset += 0.1;
            }
            
            draw() {
                const bounce = Math.sin(this.bounceOffset) * 3;
                
                // Body
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x, this.y + bounce, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye
                ctx.fillStyle = '#FF0';
                ctx.beginPath();
                ctx.arc(this.x, this.y + bounce, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x, this.y + bounce, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Teeth
                ctx.fillStyle = '#FFF';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.radius + i * 10, this.y + this.radius + bounce);
                    ctx.lineTo(this.x - this.radius + i * 10 + 5, this.y + this.radius - 8 + bounce);
                    ctx.lineTo(this.x - this.radius + i * 10 + 10, this.y + this.radius + bounce);
                    ctx.fill();
                }
            }
        }

        // Game objects
        const player = new Player();
        let projectiles = [];
        let nixels = [];
        let particles = [];
        
        const keys = {};
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let mouseDown = false;

        // Input
        document.addEventListener('keydown', e => keys[e.key] = true);
        document.addEventListener('keyup', e => keys[e.key] = false);
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        });
        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);

        // Collision
        function circleCollision(x1, y1, r1, x2, y2, r2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return dx * dx + dy * dy < (r1 + r2) * (r1 + r2);
        }

        // Spawn wave
        function spawnWave() {
            const count = Math.min(5 + (game.wave - 1) * 4, 50);
            for (let i = 0; i < count; i++) {
                setTimeout(() => nixels.push(new Nixel()), i * 200);
            }
        }

        // Draw background
        function drawBackground() {
            // Grass
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Darker grass pattern
            ctx.fillStyle = '#7CCD7C';
            for (let y = 0; y < canvas.height; y += 40) {
                for (let x = 0; x < canvas.width; x += 40) {
                    if ((x + y) % 80 === 0) {
                        ctx.fillRect(x, y, 40, 40);
                    }
                }
            }
            
            // Dirt patches
            ctx.fillStyle = '#8B7355';
            for (let i = 0; i < 10; i++) {
                const x = (i * 137 + 50) % canvas.width;
                const y = (i * 193 + 80) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Arena boundary
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.strokeRect(ARENA_BOUNDS.left, ARENA_BOUNDS.top, 
                          ARENA_BOUNDS.right - ARENA_BOUNDS.left,
                          ARENA_BOUNDS.bottom - ARENA_BOUNDS.top);
        }

        // Draw HUD
        function drawHUD() {
            // Score
            ctx.fillStyle = '#000';
            ctx.font = 'bold 28px Impact';
            ctx.fillText('Score: ' + game.score, 20, 35);
            
            // Wave
            ctx.fillText('Wave: ' + game.wave, canvas.width - 150, 35);
            
            // Shield bar
            const barWidth = 400;
            const barHeight = 30;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 20;
            
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            const shieldPercent = game.shield / 100;
            let shieldColor = '#0F0';
            if (shieldPercent < 0.5) shieldColor = '#FF0';
            if (shieldPercent < 0.25) shieldColor = '#F00';
            
            ctx.fillStyle = shieldColor;
            ctx.fillRect(barX, barY, barWidth * shieldPercent, barHeight);
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Impact';
            ctx.textAlign = 'center';
            ctx.fillText(Math.floor(game.shield) + '%', barX + barWidth / 2, barY + 21);
            ctx.textAlign = 'left';
            
            // Weapon level
            const weaponLevel = Math.floor((game.wave - 1) / 2) + 1;
            ctx.fillStyle = '#000';
            ctx.font = 'bold 20px Impact';
            ctx.fillText('Weapon: Lv.' + weaponLevel, canvas.width / 2 - 60, canvas.height - 20);
        }

        // Game loop
        function gameLoop() {
            if (game.state === 'playing') {
                // Apply shake
                ctx.save();
                if (game.shake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * game.shake,
                        (Math.random() - 0.5) * game.shake
                    );
                    game.shake *= 0.9;
                }
                
                drawBackground();
                
                // Flash effect
                if (game.flash > 0) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${game.flash})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    game.flash -= 0.05;
                }
                
                // Update
                player.update(keys, mouseX, mouseY);
                if (mouseDown) player.shoot(mouseX, mouseY);
                
                projectiles = projectiles.filter(p => p.update());
                nixels.forEach(n => n.update(player.x, player.y));
                particles = particles.filter(p => p.update());
                
                // Wave transition
                if (game.waveTransition && Date.now() > game.waveTransitionEnd) {
                    game.waveTransition = false;
                    spawnWave();
                }
                
                // Check projectile collisions
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const proj = projectiles[i];
                    for (let j = nixels.length - 1; j >= 0; j--) {
                        const nixel = nixels[j];
                        if (circleCollision(proj.x, proj.y, proj.radius, nixel.x, nixel.y, nixel.radius)) {
                            projectiles.splice(i, 1);
                            nixels.splice(j, 1);
                            game.score += 10;
                            game.kills++;
                            
                            // Particles
                            for (let k = 0; k < 10; k++) {
                                particles.push(new Particle(
                                    nixel.x, nixel.y, '#000',
                                    (Math.random() - 0.5) * 6,
                                    (Math.random() - 0.5) * 6
                                ));
                            }
                            
                            playSound(300, 100, 0.2, 'sawtooth');
                            break;
                        }
                    }
                }
                
                // Check player collisions
                if (!game.invincible) {
                    for (let i = nixels.length - 1; i >= 0; i--) {
                        const nixel = nixels[i];
                        if (circleCollision(player.x, player.y, player.size, nixel.x, nixel.y, nixel.radius)) {
                            nixels.splice(i, 1);
                            game.shield -= 8;
                            game.invincible = true;
                            game.invincibleEnd = Date.now() + 500;
                            game.shake = 5;
                            game.flash = 0.3;
                            
                            // Red particles
                            for (let k = 0; k < 12; k++) {
                                particles.push(new Particle(
                                    player.x, player.y, '#F00',
                                    (Math.random() - 0.5) * 8,
                                    (Math.random() - 0.5) * 8
                                ));
                            }
                            
                            playSound(80, 60, 0.15, 'square');
                            
                            if (game.shield <= 0) {
                                game.state = 'gameOver';
                                playSound(500, 50, 1, 'sawtooth');
                                document.getElementById('finalStats').innerHTML = `
                                    Final Score: ${game.score}<br>
                                    Highest Wave: ${game.wave}<br>
                                    Nixels Defeated: ${game.kills}<br>
                                    Time Survived: ${Math.floor((Date.now() - game.startTime) / 1000)}s
                                `;
                                document.getElementById('gameOverScreen').classList.remove('hidden');
                            }
                        }
                    }
                }
                
                if (game.invincible && Date.now() > game.invincibleEnd) {
                    game.invincible = false;
                }
                
                // Check wave clear
                if (nixels.length === 0 && !game.waveTransition) {
                    game.wave++;
                    game.score += (game.wave - 1) * 50;
                    game.waveTransition = true;
                    game.waveTransitionEnd = Date.now() + 2000;
                    playSound(400, 600, 0.5, 'sine');
                }
                
                // Draw
                player.draw();
                projectiles.forEach(p => p.draw());
                nixels.forEach(n => n.draw());
                particles.forEach(p => p.draw());
                
                // Wave transition text
                if (game.waveTransition) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, canvas.height / 2 - 60, canvas.width, 120);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 64px Impact';
                    ctx.textAlign = 'center';
                    ctx.fillText('WAVE ' + game.wave, canvas.width / 2, canvas.height / 2 + 20);
                    ctx.textAlign = 'left';
                }
                
                drawHUD();
                ctx.restore();
            }
            
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            game.state = 'playing';
            game.score = 0;
            game.wave = 1;
            game.shield = 100;
            game.kills = 0;
            game.startTime = Date.now();
            game.invincible = false;
            game.waveTransition = false;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            projectiles = [];
            nixels = [];
            particles = [];
            spawnWave();
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        }

        function toMainMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            game.state = 'menu';
        }

        gameLoop();
    </script>
</body>
</html>