<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Ops</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { 
            background: #0a0a0a; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; 
            color: white; 
        }
        #gameContainer { 
            position: relative; 
            border: 2px solid #333; 
            max-width: 100%;
            max-height: 100vh;
        }
        canvas { 
            display: block; 
            background: #1b2e1f; 
            max-width: 100%; 
            height: auto; 
            aspect-ratio: 10 / 6;
        }
        
        #ui-layer {
            position: absolute; top: 10px; left: 10px; right: 10px;
            pointer-events: none; display: flex; justify-content: space-between;
            font-size: 14px;
        }
        .stat-box { background: rgba(0,0,0,0.8); padding: 5px 10px; border-radius: 5px; border: 1px solid #444; }
        
        #boss-ui {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 80%; display: none; text-align: center;
        }
        .hp-bg { width: 100%; height: 8px; background: #300; border: 1px solid #ff4444; margin-top: 5px; }
        #boss-hp-bar { width: 100%; height: 100%; background: #ff0000; }
        
        #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); padding: 30px; text-align: center; 
            display: none; border: 3px solid #ff0000; z-index: 100; width: 80%;
        }
        button { padding: 12px 24px; font-size: 18px; cursor: pointer; background: #ff4444; color: white; border: none; border-radius: 5px; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        <div id="ui-layer">
            <div class="stat-box">Score: <span id="scoreVal">0</span></div>
            <div class="stat-box" style="text-align: center;">
                <div style="width: 100px; height: 10px; background: #222; border: 1px solid #fff;">
                    <div id="healthBar" style="width: 100%; height: 100%; background: #00ff00;"></div>
                </div>
            </div>
            <div class="stat-box">Buff: <span id="buffName" style="color: #00f2ff;">NONE</span></div>
        </div>

        <div id="boss-ui">
            <div style="color: #ff4444; font-weight: bold; font-size: 12px;">BOSS</div>
            <div class="hp-bg"><div id="boss-hp-bar"></div></div>
        </div>

        <div id="gameOver">
            <h1 style="color: #ff0000;">DEFEATED</h1>
            <p id="stats" style="margin: 10px 0;"></p>
            <button onclick="location.reload()">RETRY</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000; canvas.height = 600;

        let game = { score: 0, health: 100, running: true, shake: 0, nextBoss: 200 };
        let player = { x: 500, y: 300, size: 25, speed: 5, angle: 0, flash: 0, powerup: null, pTimer: 0 };
        
        let actors = [];
        let projectiles = [];
        let mouse = { x: 500, y: 300, down: false };
        let lastShot = 0;
        let spawnTimer = 0;

        // --- AUDIO SYSTEM ---
        let audioCtx = null;
        let musicGainNode = null;
        let sfxGainNode = null;
        let audioInitialized = false;

        // Initialize audio on first user interaction
        function initAudio() {
            if (audioInitialized) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create gain nodes for volume control
            musicGainNode = audioCtx.createGain();
            musicGainNode.connect(audioCtx.destination);
            musicGainNode.gain.value = 0.3; // Music volume (30%)
            
            sfxGainNode = audioCtx.createGain();
            sfxGainNode.connect(audioCtx.destination);
            sfxGainNode.gain.value = 0.5; // SFX volume (50%)
            
            audioInitialized = true;
            playBackgroundMusic();
        }

        // Background music loop
        function playBackgroundMusic() {
            if (!audioCtx) return;
            
            const notes = [
                { freq: 220, duration: 0.3 },  // A
                { freq: 247, duration: 0.3 },  // B
                { freq: 277, duration: 0.3 },  // C#
                { freq: 294, duration: 0.3 },  // D
                { freq: 330, duration: 0.6 },  // E
                { freq: 294, duration: 0.3 },  // D
                { freq: 277, duration: 0.3 },  // C#
                { freq: 247, duration: 0.6 }   // B
            ];
            
            let currentNote = 0;
            
            function playNote() {
                if (!game.running || !audioCtx) return;
                
                const note = notes[currentNote];
                const osc = audioCtx.createOscillator();
                const noteGain = audioCtx.createGain();
                
                osc.type = 'square';
                osc.frequency.value = note.freq;
                
                osc.connect(noteGain);
                noteGain.connect(musicGainNode);
                
                noteGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                noteGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + note.duration);
                
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + note.duration);
                
                currentNote = (currentNote + 1) % notes.length;
                setTimeout(playNote, note.duration * 1000);
            }
            
            playNote();
        }

        // Shooting sound
        function playShotSound() {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.frequency.value = 800;
            osc.type = 'sawtooth';
            
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.08);
        }

        // Hit/damage sound
        function playHitSound() {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.frequency.value = 150;
            osc.type = 'sawtooth';
            
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.2);
        }

        // Powerup sound
        function playPowerupSound() {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.2);
        }

        // Enemy kill sound
        function playKillSound() {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(sfxGainNode);
            
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
            osc.type = 'square';
            
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.15);
        }

        // Boss defeat sound
        function playBossDefeatSound() {
            if (!audioCtx) return;
            
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(sfxGainNode);
                    
                    osc.frequency.value = 200 - (i * 50);
                    osc.type = 'sawtooth';
                    
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                }, i * 100);
            }
        }

        // --- MOBILE TOUCH CONTROLS ---
        function handleTouch(e) {
            e.preventDefault();
            
            // Initialize audio on first touch
            if (!audioInitialized) {
                initAudio();
            }
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            // Scale touch coordinates to canvas internal size
            mouse.x = (touch.clientX - rect.left) * (canvas.width / rect.width);
            mouse.y = (touch.clientY - rect.top) * (canvas.height / rect.height);
            mouse.down = true;
        }

        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});
        canvas.addEventListener('touchend', () => mouse.down = false);

        // Desktop fallbacks
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        });
        canvas.addEventListener('mousedown', () => { 
            if (!audioInitialized) initAudio();
            mouse.down = true; 
        });
        canvas.addEventListener('mouseup', () => mouse.down = false);

        function spawnActor(type = 'normal') {
            if (!game.running) return;
            const isCiv = Math.random() < 0.25;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            if (side === 0) { x = Math.random() * canvas.width; y = -100; }
            else if (side === 1) { x = canvas.width + 100; y = Math.random() * canvas.height; }
            else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 100; }
            else { x = -100; y = Math.random() * canvas.height; }

            if (type === 'boss') {
                actors.push({ x, y, emoji: 'ðŸ¦–', isBoss: true, hp: 15, maxHp: 15, speed: 0.8, size: 80 });
                document.getElementById('boss-ui').style.display = 'block';
            } else {
                actors.push({
                    x, y, isCiv, size: 28, 
                    emoji: isCiv ? ['ðŸƒ','ðŸ•º','ðŸš¶'][Math.floor(Math.random()*3)] : ['ðŸ‘¾','ðŸ‘½','ðŸ¤–'][Math.floor(Math.random()*3)],
                    speed: isCiv ? 2.8 : 1.5 + (game.score/1500)
                });
            }
        }

        function update() {
            if (!game.running) { game.shake = 0; return; }

            if (player.pTimer > 0) {
                player.pTimer--;
                if (player.pTimer <= 0) player.powerup = null;
            }
            document.getElementById('buffName').innerText = player.powerup || "NONE";

            // Mobile/Mouse Movement Logic: Smoothly follow touch point
            if (mouse.down) {
                const distToTouch = Math.hypot(mouse.x - player.x, mouse.y - player.y);
                if (distToTouch > 5) { // Only move if finger is far enough
                    const angleToTouch = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                    player.x += Math.cos(angleToTouch) * player.speed;
                    player.y += Math.sin(angleToTouch) * player.speed;
                    player.angle = angleToTouch;
                }
            }

            // Automatic Shooting while touching
            const rate = player.powerup === 'MACHINEGUN' ? 80 : 200;
            if (mouse.down && Date.now() - lastShot > rate) {
                projectiles.push({ x: player.x, y: player.y, angle: player.angle });
                lastShot = Date.now();
                player.flash = 2;
                game.shake = 3;
                playShotSound();
            }

            if (game.score >= game.nextBoss) { spawnActor('boss'); game.nextBoss += 200; }

            for (let pi = projectiles.length - 1; pi >= 0; pi--) {
                const p = projectiles[pi];
                p.x += Math.cos(p.angle) * 16; p.y += Math.sin(p.angle) * 16;
                if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) projectiles.splice(pi, 1);
            }

            for (let i = actors.length - 1; i >= 0; i--) {
                const a = actors[i];
                const ang = Math.atan2(player.y - a.y, player.x - a.x);
                a.x += Math.cos(ang) * a.speed; a.y += Math.sin(ang) * a.speed;
                const dist = Math.hypot(player.x - a.x, player.y - a.y);

                if (player.powerup === 'SHIELD' && dist < 75) {
                    if (!a.isCiv) {
                        if (a.isBoss) { a.x -= Math.cos(ang)*15; a.y -= Math.sin(ang)*15; }
                        else { actors.splice(i, 1); continue; }
                    }
                }

                if (dist < a.size + 15) {
                    if (a.isCiv) {
                        player.powerup = Math.random() < 0.5 ? 'MACHINEGUN' : 'SHIELD';
                        player.pTimer = 400;
                        game.health = Math.min(100, game.health + 15);
                        actors.splice(i, 1);
                        playPowerupSound();
                    } else {
                        game.health -= a.isBoss ? 0.5 : 10;
                        game.shake = 8;
                        playHitSound();
                        if (!a.isBoss) actors.splice(i, 1);
                    }
                    continue;
                }

                for (let pi = projectiles.length - 1; pi >= 0; pi--) {
                    const p = projectiles[pi];
                    if (Math.hypot(p.x - a.x, p.y - a.y) < a.size) {
                        projectiles.splice(pi, 1);
                        if (a.isCiv) { 
                            game.health -= 25; 
                            game.shake = 35; 
                            actors.splice(i, 1); 
                            playHitSound();
                        }
                        else if (a.isBoss) {
                            a.hp--;
                            playHitSound();
                            document.getElementById('boss-hp-bar').style.width = (a.hp/a.maxHp)*100 + '%';
                            if (a.hp <= 0) {
                                game.score += 100; actors.splice(i, 1);
                                document.getElementById('boss-ui').style.display = 'none';
                                player.powerup = 'MACHINEGUN'; player.pTimer = 600;
                                playBossDefeatSound();
                            }
                        } else { 
                            game.score += 10; 
                            actors.splice(i, 1); 
                            playKillSound();
                        }
                        break;
                    }
                }
            }

            if (game.health <= 0) { 
                game.running = false; 
                document.getElementById('gameOver').style.display = 'block'; 
                document.getElementById('stats').innerText = `Final Score: ${game.score}`; 
            }
            if (spawnTimer++ > 60) { spawnActor(); spawnTimer = 0; }
            document.getElementById('scoreVal').innerText = game.score;
            document.getElementById('healthBar').style.width = game.health + '%';
            if (game.shake > 0) game.shake *= 0.9;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            if (game.running && game.shake > 0.5) ctx.translate((Math.random()-0.5)*game.shake, (Math.random()-0.5)*game.shake);
            
            ctx.fillStyle = '#1b2e1f'; ctx.fillRect(0,0,canvas.width,canvas.height);

            if (game.running && player.powerup === 'SHIELD') {
                ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 3; ctx.beginPath();
                ctx.arc(player.x, player.y, 75, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = 'rgba(0, 242, 255, 0.15)'; ctx.fill();
            }

            ctx.fillStyle = '#ffff00';
            projectiles.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); });

            actors.forEach(a => {
                ctx.font = a.isBoss ? '80px Arial' : '32px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(a.emoji, a.x, a.y);
            });

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            ctx.fillStyle = '#cd853f'; ctx.beginPath(); ctx.ellipse(0, 0, 22, 16, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#333'; ctx.fillRect(12, -2, 35, 8); 
            if (player.flash-- > 0) {
                ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(50, 2, 12, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
            ctx.restore();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
        loop();
    </script>
</body>
</html>