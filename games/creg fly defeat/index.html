<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craig's Creek Defender</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(to bottom, #87CEEB, #98D8C8);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background: #87CEEB;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        const GAME_WIDTH = 1280;
        const GAME_HEIGHT = 720;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Responsive scaling
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const ratio = GAME_WIDTH / GAME_HEIGHT;
            const windowRatio = window.innerWidth / window.innerHeight;
            
            if (windowRatio > ratio) {
                container.style.height = window.innerHeight * 0.95 + 'px';
                container.style.width = (window.innerHeight * 0.95 * ratio) + 'px';
            } else {
                container.style.width = window.innerWidth * 0.95 + 'px';
                container.style.height = (window.innerWidth * 0.95 / ratio) + 'px';
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        const game = {
            state: 'playing', // 'playing' or 'gameOver'
            score: 0,
            health: 5,
            maxHealth: 5,
            lastPowerUpScore: 0,
            invincible: false,
            invincibleTime: 0,
            shakeMagnitude: 0,
            comboHits: [],
            lastShotTime: 0,
            fireRate: 300,
            powerUp: null,
            powerUpEndTime: 0
        };

        // Particle class
        class Particle {
            constructor(x, y, color, speed = 2) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * speed * 2;
                this.vy = (Math.random() - 0.5) * speed * 2;
                this.color = color;
                this.life = 1;
                this.decay = 0.02;
                this.size = Math.random() * 4 + 2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                return this.life > 0;
            }
            
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = GAME_WIDTH * 0.15;
                this.y = GAME_HEIGHT / 2;
                this.targetY = this.y;
                this.width = 40;
                this.height = 40;
            }
            
            update() {
                // Smooth interpolation
                this.y += (this.targetY - this.y) * 0.15;
                
                // Keep in bounds
                if (this.y < this.height/2) this.y = this.height/2;
                if (this.y > GAME_HEIGHT - this.height/2) this.y = GAME_HEIGHT - this.height/2;
            }
            
            draw() {
                const shake = game.shakeMagnitude > 0 ? 
                    {x: (Math.random() - 0.5) * game.shakeMagnitude, 
                     y: (Math.random() - 0.5) * game.shakeMagnitude} : 
                    {x: 0, y: 0};
                
                // Shield effect
                if (game.powerUp === 'shield') {
                    ctx.strokeStyle = '#4DD0E1';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + shake.x, this.y + shake.y, this.width, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Invincibility flash
                if (game.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Body
                ctx.fillStyle = '#FF8C42';
                ctx.fillRect(this.x - this.width/2 + shake.x, this.y - this.height/2 + shake.y, 
                            this.width, this.height);
                
                // Face
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(this.x + shake.x, this.y - 5 + shake.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - 6 + shake.x, this.y - 8 + shake.y, 3, 3);
                ctx.fillRect(this.x + 3 + shake.x, this.y - 8 + shake.y, 3, 3);
                
                // Hat
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(this.x - 10 + shake.x, this.y - 18 + shake.y, 20, 4);
                ctx.fillRect(this.x - 6 + shake.x, this.y - 24 + shake.y, 12, 8);
                
                ctx.globalAlpha = 1;
            }
            
            getBounds() {
                return {
                    x: this.x - this.width/2,
                    y: this.y - this.height/2,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, angle = 0) {
                this.x = x;
                this.y = y;
                this.speed = 12;
                this.width = 12;
                this.height = 6;
                this.angle = angle;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                return this.x < GAME_WIDTH + 50;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(-this.width/2, -this.height/2, this.width/2, this.height);
                ctx.restore();
            }
            
            getBounds() {
                return {
                    x: this.x - this.width/2,
                    y: this.y - this.height/2,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // Enemy class
        class Enemy {
            constructor(type = 'basic') {
    this.type = type;
    this.x = GAME_WIDTH + 50;
    this.y = Math.random() * (GAME_HEIGHT - 100) + 50;
    this.startY = this.y;
    this.time = 0;

    // Difficulty scaling: speed increases by 10% every 10 points
    const difficultyMultiplier = 1 + (Math.floor(game.score / 100) * 0.1);
    
    if (type === 'basic') {
        this.hp = 1;
        this.maxHp = 1;
        this.speed = 4 * difficultyMultiplier; // Increased from 2.5
        this.size = 25;
        this.points = 10;
        this.amplitude = 60;
        this.frequency = 0.03;
    } else if (type === 'armored') {
        this.hp = 3;
        this.maxHp = 3;
        this.speed = 4 * difficultyMultiplier; // Increased from 1.5
        this.size = 35;
        this.points = 30;
        this.amplitude = 40;
        this.frequency = 0.02;
    } else { // speed type
        this.hp = 1;
        this.maxHp = 1;
        this.speed = 8 * difficultyMultiplier; // Increased from 5
        this.size = 20;
        this.points = 25;
        this.amplitude = 80;
        this.frequency = 0.05;
    }
}
            
            update() {
                this.x -= this.speed;
                this.time += this.frequency;
                this.y = this.startY + Math.sin(this.time) * this.amplitude;
                return this.x > -100;
            }
            
            draw() {
                // Body
                ctx.fillStyle = this.type === 'armored' ? '#666' : 
                               this.type === 'speed' ? '#FF6B6B' : '#444';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                const wingOffset = Math.sin(Date.now() * 0.01) * 5;
                ctx.beginPath();
                ctx.ellipse(this.x - this.size/2, this.y + wingOffset, 
                           this.size * 0.8, this.size * 0.4, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.x - this.size/2, this.y - wingOffset, 
                           this.size * 0.8, this.size * 0.4, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes (red for mechanical)
                ctx.fillStyle = '#F00';
                ctx.fillRect(this.x + this.size/3, this.y - 5, 4, 4);
                ctx.fillRect(this.x + this.size/3, this.y + 2, 4, 4);
                
                // HP bar for armored
                if (this.type === 'armored' && this.hp < this.maxHp) {
                    ctx.fillStyle = '#F00';
                    ctx.fillRect(this.x - 20, this.y - this.size - 10, 40, 4);
                    ctx.fillStyle = '#0F0';
                    ctx.fillRect(this.x - 20, this.y - this.size - 10, 
                                40 * (this.hp / this.maxHp), 4);
                }
            }
            
            getBounds() {
                return {
                    x: this.x - this.size,
                    y: this.y - this.size,
                    width: this.size * 2,
                    height: this.size * 2
                };
            }
            
            hit() {
                this.hp--;
                return this.hp <= 0;
            }
        }

        // PowerUp class
        class PowerUp {
            constructor() {
                this.x = GAME_WIDTH + 50;
                this.y = Math.random() * (GAME_HEIGHT - 100) + 50;
                this.size = 30;
                this.speed = 2;
                this.rotation = 0;
                const types = ['rapid', 'spread', 'shield'];
                this.type = types[Math.floor(Math.random() * types.length)];
            }
            
            update() {
                this.x -= this.speed;
                this.rotation += 0.05;
                return this.x > -100;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Choco-roll
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.fillStyle = '#D2691E';
                ctx.fillRect(-this.size/2 + 3, -this.size/2 + 3, this.size - 6, this.size - 6);
                
                // Sparkle
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-2, -this.size/2 - 8, 4, 8);
                ctx.fillRect(-this.size/2 - 8, -2, 8, 4);
                
                ctx.restore();
            }
            
            getBounds() {
                return {
                    x: this.x - this.size/2,
                    y: this.y - this.size/2,
                    width: this.size,
                    height: this.size
                };
            }
        }

        // Game objects
        const player = new Player();
        let projectiles = [];
        let enemies = [];
        let particles = [];
        let powerUp = null;
        let lastEnemySpawn = Date.now();
        let bgOffset = 0;

        // Input handling
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleY = GAME_HEIGHT / rect.height;
            player.targetY = (e.clientY - rect.top) * scaleY;
        });

        let keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'r' && game.state === 'gameOver') {
                resetGame();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Collision detection
        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        // Shoot projectile
        function shoot() {
            const now = Date.now();
            const currentFireRate = game.powerUp === 'rapid' ? game.fireRate / 2 : game.fireRate;
            
            if (now - game.lastShotTime < currentFireRate) return;
            game.lastShotTime = now;
            
            if (game.powerUp === 'spread') {
                projectiles.push(new Projectile(player.x + 20, player.y, 0));
                projectiles.push(new Projectile(player.x + 20, player.y, -0.2));
                projectiles.push(new Projectile(player.x + 20, player.y, 0.2));
            } else {
                projectiles.push(new Projectile(player.x + 20, player.y));
            }
        }

        // Spawn enemy
        function spawnEnemy() {
            const rand = Math.random();
            let type = 'basic';
            if (rand > 0.95) type = 'speed';
            else if (rand > 0.70) type = 'armored';
            enemies.push(new Enemy(type));
        }

        // Create particles
        function createExplosion(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, 3));
            }
        }

        // Draw background
        function drawBackground() {
            bgOffset = (bgOffset + 1) % GAME_WIDTH;
            
            // Sky
            const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98D8C8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Mountains (far)
            ctx.fillStyle = '#7FB069';
            for (let i = -1; i < 3; i++) {
                const x = i * 400 - bgOffset * 0.2;
                ctx.beginPath();
                ctx.moveTo(x, GAME_HEIGHT);
                ctx.lineTo(x + 200, GAME_HEIGHT - 150);
                ctx.lineTo(x + 400, GAME_HEIGHT);
                ctx.fill();
            }
            
            // Trees (mid)
            ctx.fillStyle = '#52796F';
            for (let i = -1; i < 6; i++) {
                const x = i * 250 - bgOffset * 0.5;
                ctx.fillRect(x + 120, GAME_HEIGHT - 100, 10, 60);
                ctx.beginPath();
                ctx.arc(x + 125, GAME_HEIGHT - 90, 30, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Grass (fore)
            ctx.fillStyle = '#84A98C';
            for (let i = -1; i < 8; i++) {
                const x = i * 200 - bgOffset;
                for (let j = 0; j < 5; j++) {
                    ctx.fillRect(x + j * 40, GAME_HEIGHT - 30 + Math.sin(j) * 5, 8, 30);
                }
            }
        }

        // Draw UI
        function drawUI() {
            // Health hearts
            ctx.fillStyle = '#F00';
            for (let i = 0; i < game.health; i++) {
                ctx.beginPath();
                ctx.arc(30 + i * 40, 40, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(45 + i * 40, 40, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(30 + i * 40, 50);
                ctx.lineTo(37.5 + i * 40, 60);
                ctx.lineTo(45 + i * 40, 50);
                ctx.fill();
            }
            
            // Score
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.font = 'bold 36px Comic Sans MS';
            ctx.strokeText('Score: ' + game.score, GAME_WIDTH - 250, 50);
            ctx.fillText('Score: ' + game.score, GAME_WIDTH - 250, 50);
            
            // Power-up indicator
            if (game.powerUp && Date.now() < game.powerUpEndTime) {
                const timeLeft = Math.ceil((game.powerUpEndTime - Date.now()) / 1000);
                ctx.font = 'bold 24px Comic Sans MS';
                const text = game.powerUp.toUpperCase() + ': ' + timeLeft + 's';
                ctx.strokeText(text, GAME_WIDTH - 250, 90);
                ctx.fillText(text, GAME_WIDTH - 250, 90);
            }
        }

        // Reset game
        function resetGame() {
            game.state = 'playing';
            game.score = 0;
            game.health = 5;
            game.lastPowerUpScore = 0;
            game.invincible = false;
            game.powerUp = null;
            projectiles = [];
            enemies = [];
            particles = [];
            powerUp = null;
            player.y = GAME_HEIGHT / 2;
            player.targetY = GAME_HEIGHT / 2;
        }

        // Game loop
        function gameLoop() {
            if (game.state === 'playing') {
                // Update
                player.update();
                
                // Keyboard movement
                if (keys['ArrowUp']) player.targetY -= 8;
                if (keys['ArrowDown']) player.targetY += 8;
                if (keys[' ']) shoot();
                
                // Auto shoot
                shoot();
                
                // Update projectiles
                projectiles = projectiles.filter(p => p.update());
                
                // Update enemies
                enemies = enemies.filter(e => e.update());
                
                // Spawn enemies
               // Spawn enemies
                const now = Date.now();
                // Calculate dynamic spawn rate (starts at 2000ms, drops as score goes up, floor at 400ms)
                const currentSpawnRate = Math.max(400, 200 - (Math.floor(game.score / 150) * 100));

                if (now - lastEnemySpawn > currentSpawnRate) {
                    spawnEnemy();
                    
                    // Chance for a "Double Spawn" once score is over 1000
                    if (game.score > 50 && Math.random() > 0.7) {
                        spawnEnemy();
                    }
                    
                    lastEnemySpawn = now;
                }
                
                // Update particles
                particles = particles.filter(p => p.update());
                
                // Check projectile-enemy collisions
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const proj = projectiles[i];
                    const projBounds = proj.getBounds();
                    
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const enemyBounds = enemy.getBounds();
                        
                        if (checkCollision(projBounds, enemyBounds)) {
                            projectiles.splice(i, 1);
                            
                            if (enemy.hit()) {
                                game.score += enemy.points;
                                game.comboHits.push(Date.now());
                                createExplosion(enemy.x, enemy.y, '#FFA500', 10);
                                enemies.splice(j, 1);
                                
                                // Check combo
                                game.comboHits = game.comboHits.filter(t => Date.now() - t < 2000);
                                if (game.comboHits.length >= 3) {
                                    game.score += 5;
                                }
                            }
                            break;
                        }
                    }
                }
                
                // Check player-enemy collisions
                if (!game.invincible) {
                    const playerBounds = player.getBounds();
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const enemyBounds = enemy.getBounds();
                        
                        if (checkCollision(playerBounds, enemyBounds)) {
                            if (game.powerUp === 'shield') {
                                game.powerUp = null;
                            } else {
                                game.health--;
                                game.invincible = true;
                                game.invincibleTime = Date.now();
                                game.shakeMagnitude = 10;
                            }
                            createExplosion(enemy.x, enemy.y, '#FF6B6B', 10);
                            enemies.splice(i, 1);
                            
                            if (game.health <= 0) {
                                game.state = 'gameOver';
                            }
                        }
                    }
                }
                
                // Update invincibility
                if (game.invincible && Date.now() - game.invincibleTime > 1000) {
                    game.invincible = false;
                }
                
                // Update screen shake
                if (game.shakeMagnitude > 0) {
                    game.shakeMagnitude *= 0.9;
                    if (game.shakeMagnitude < 0.5) game.shakeMagnitude = 0;
                }
                
                // Update power-up duration
                if (game.powerUp && Date.now() >= game.powerUpEndTime) {
                    game.powerUp = null;
                }
                
                // Spawn power-up
                if (!powerUp && game.score - game.lastPowerUpScore >= 150) {
                    powerUp = new PowerUp();
                    game.lastPowerUpScore = game.score;
                }
                
                // Update power-up
                if (powerUp) {
                    if (!powerUp.update()) {
                        powerUp = null;
                    } else {
                        const powerUpBounds = powerUp.getBounds();
                        const playerBounds = player.getBounds();
                        if (checkCollision(playerBounds, powerUpBounds)) {
                            game.powerUp = powerUp.type;
                            game.powerUpEndTime = Date.now() + 8000;
                            createExplosion(powerUp.x, powerUp.y, '#4DD0E1', 20);
                            powerUp = null;
                        }
                    }
                }
                
                // Health bonus
                if (game.score > 0 && game.score % 500 === 0 && game.health < game.maxHealth) {
                    game.health++;
                }
            }
            
            // Draw
            drawBackground();
            
            if (game.state === 'playing') {
                player.draw();
                projectiles.forEach(p => p.draw());
                enemies.forEach(e => e.draw());
                if (powerUp) powerUp.draw();
                particles.forEach(p => p.draw());
                drawUI();
            } else {
                // Game Over screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                ctx.fillStyle = '#FFF';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 6;
                ctx.font = 'bold 72px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.strokeText('GAME OVER', GAME_WIDTH/2, GAME_HEIGHT/2 - 50);
                ctx.fillText('GAME OVER', GAME_WIDTH/2, GAME_HEIGHT/2 - 50);
                
                ctx.font = 'bold 48px Comic Sans MS';
                ctx.strokeText('Final Score: ' + game.score, GAME_WIDTH/2, GAME_HEIGHT/2 + 30);
                ctx.fillText('Final Score: ' + game.score, GAME_WIDTH/2, GAME_HEIGHT/2 + 30);
                
                ctx.font = 'bold 36px Comic Sans MS';
                ctx.strokeText('Press R to Restart', GAME_WIDTH/2, GAME_HEIGHT/2 + 100);
                ctx.fillText('Press R to Restart', GAME_WIDTH/2, GAME_HEIGHT/2 + 100);
                
                ctx.textAlign = 'left';
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Start game
        gameLoop();
    </script>
</body>
</html>