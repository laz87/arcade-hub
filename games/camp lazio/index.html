<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camp Lazlo: Paintcan Panic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #89CFF0 0%, #67B26F 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
        }
        
        #gameCanvas {
            display: block;
            background: #f5f5dc;
            border: 4px solid #8B4513;
        }
        
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .progress-bar {
            width: 100%;
            height: 25px;
            background: #ddd;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            border: 2px solid #333;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .level-info {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }
        
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            z-index: 100;
            min-width: 300px;
            border: 4px solid #FFD700;
        }
        
        .modal h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 3px 3px 0 #FF6347;
        }
        
        .modal p {
            font-size: 18px;
            margin: 10px 0;
            line-height: 1.6;
        }
        
        .modal button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(255,215,0,0.4);
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(255,215,0,0.6);
        }
        
        .controls {
            font-size: 14px;
            margin: 15px 0;
            color: #FFD700;
        }
        
        .caught-overlay {
            background: rgba(255,0,0,0.95) !important;
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-48%, -50%); }
            20%, 40%, 60%, 80% { transform: translate(-52%, -50%); }
        }
        
        .complete-overlay {
            background: rgba(0,128,0,0.95) !important;
        }
        
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 50;
        }
        
        .dpad {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 10px;
        }
        
        .dpad-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.8);
            border: 2px solid #333;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            touch-action: none;
        }
        
        .dpad-btn:active {
            background: rgba(255,215,0,0.8);
        }
        
        .dpad-up { top: 0; left: 40px; }
        .dpad-down { bottom: 0; left: 40px; }
        .dpad-left { top: 40px; left: 0; }
        .dpad-right { top: 40px; right: 0; }
        
        .hop-btn {
            width: 80px;
            height: 80px;
            background: rgba(255,215,0,0.9);
            border: 3px solid #333;
            border-radius: 50%;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .hop-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="hud" id="hud" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div class="level-info">
                <span>Level: <span id="levelNum">1</span></span>
                <span>Target: <span id="targetPercent">75</span>%</span>
            </div>
        </div>
        
        <div class="modal" id="startModal">
            <h1>CAMP LAZLO</h1>
            <h2 style="color: #FF6347;">Paintcan Panic!</h2>
            <div class="controls">
                <p>üéÆ Arrow Keys / WASD to Move</p>
                <p>ü¶ò SPACE to Hop over Obstacles</p>
                <p>üé® Collect Paint Cans & Cover the Floor!</p>
                <p>üëÄ Avoid Counselor Vision Cones!</p>
            </div>
            <button onclick="game.startGame()">START GAME</button>
        </div>
        
        <div class="mobile-controls">
            <div class="dpad">
                <div class="dpad-btn dpad-up" data-dir="up">‚ñ≤</div>
                <div class="dpad-btn dpad-down" data-dir="down">‚ñº</div>
                <div class="dpad-btn dpad-left" data-dir="left">‚óÑ</div>
                <div class="dpad-btn dpad-right" data-dir="right">‚ñ∫</div>
            </div>
            <div class="hop-btn">HOP</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRID_SIZE = 20;
        const TILE_SIZE = 30;
        const CANVAS_SIZE = GRID_SIZE * TILE_SIZE;
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;
        
        // Colors
        const COLORS = {
            unpainted: '#e0e0e0',
            painted: ['#00BFFF', '#32CD32', '#FF69B4', '#FFD700'],
            obstacle: '#8B4513',
            player: '#FF6347',
            counselor: '#DC143C',
            visionCone: 'rgba(255, 215, 0, 0.3)',
            paintCan: '#1E90FF'
        };
        
        // Level data
        const LEVELS = [
            {
                number: 1,
                target: 75,
                counselors: [
                    { startX: 5, startY: 10, patrol: 'horizontal', range: [3, 12], speed: 1.5 },
                    { startX: 15, startY: 10, patrol: 'vertical', range: [5, 15], speed: 1.5 }
                ],
                obstacles: [
                    { x: 10, y: 5 }, { x: 10, y: 6 },
                    { x: 8, y: 14 }, { x: 11, y: 14 }
                ],
                paintCans: 5
            },
            {
                number: 2,
                target: 80,
                counselors: [
                    { startX: 5, startY: 5, patrol: 'horizontal', range: [2, 10], speed: 2 },
                    { startX: 15, startY: 10, patrol: 'vertical', range: [5, 15], speed: 1.8 },
                    { startX: 10, startY: 15, patrol: 'horizontal', range: [8, 18], speed: 2 }
                ],
                obstacles: [
                    { x: 7, y: 7 }, { x: 12, y: 7 },
                    { x: 7, y: 13 }, { x: 12, y: 13 },
                    { x: 10, y: 10 }
                ],
                paintCans: 6
            },
            {
                number: 3,
                target: 85,
                counselors: [
                    { startX: 4, startY: 8, patrol: 'rectangle', points: [{x:4,y:8},{x:10,y:8},{x:10,y:12},{x:4,y:12}], speed: 2.2 },
                    { startX: 15, startY: 6, patrol: 'vertical', range: [3, 16], speed: 2.5 },
                    { startX: 10, startY: 3, patrol: 'horizontal', range: [5, 15], speed: 2.3 },
                    { startX: 8, startY: 16, patrol: 'horizontal', range: [2, 14], speed: 2 }
                ],
                obstacles: [
                    { x: 3, y: 3 }, { x: 16, y: 3 },
                    { x: 3, y: 16 }, { x: 16, y: 16 },
                    { x: 10, y: 10 }, { x: 9, y: 10 }, { x: 11, y: 10 }
                ],
                paintCans: 7
            }
        ];
        
        // Game state
        const game = {
            state: 'menu',
            currentLevel: 0,
            grid: [],
            player: { x: 1, y: 1, direction: 'right', painted: false, paintColor: 0, moving: false, hopAnimation: 0 },
            counselors: [],
            obstacles: new Set(),
            paintCans: [],
            particles: [],
            paintedCount: 0,
            screenShake: 0,
            keys: {},
            lastMoveTime: 0,
            moveDelay: 150,
            
            init() {
                this.setupMobileControls();
                this.setupKeyboard();
            },
            
            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (this.state === 'playing' && !this.player.moving) {
                        const now = Date.now();
                        if (now - this.lastMoveTime < this.moveDelay) return;
                        
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.hop();
                        } else if (['arrowup', 'w'].includes(e.key.toLowerCase())) {
                            e.preventDefault();
                            this.movePlayer('up');
                        } else if (['arrowdown', 's'].includes(e.key.toLowerCase())) {
                            e.preventDefault();
                            this.movePlayer('down');
                        } else if (['arrowleft', 'a'].includes(e.key.toLowerCase())) {
                            e.preventDefault();
                            this.movePlayer('left');
                        } else if (['arrowright', 'd'].includes(e.key.toLowerCase())) {
                            e.preventDefault();
                            this.movePlayer('right');
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            },
            
            setupMobileControls() {
                document.querySelectorAll('.dpad-btn').forEach(btn => {
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if (this.state === 'playing' && !this.player.moving) {
                            const dir = btn.dataset.dir;
                            this.movePlayer(dir);
                        }
                    });
                });
                
                document.querySelector('.hop-btn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.state === 'playing' && !this.player.moving) {
                        this.hop();
                    }
                });
            },
            
            startGame() {
                document.getElementById('startModal').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                this.currentLevel = 0;
                this.loadLevel();
                this.state = 'playing';
                requestAnimationFrame(() => this.gameLoop());
            },
            
            loadLevel() {
                const level = LEVELS[this.currentLevel];
                
                // Initialize grid
                this.grid = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        this.grid[y][x] = { painted: false, color: 0 };
                    }
                }
                
                // Reset player
                this.player = { x: 1, y: 1, direction: 'right', painted: false, paintColor: 0, moving: false, hopAnimation: 0 };
                
                // Setup obstacles
                this.obstacles = new Set();
                level.obstacles.forEach(obs => {
                    this.obstacles.add(`${obs.x},${obs.y}`);
                });
                
                // Setup counselors
                this.counselors = level.counselors.map(c => ({
                    x: c.startX,
                    y: c.startY,
                    direction: c.patrol === 'horizontal' ? 'right' : 'down',
                    patrol: c.patrol,
                    range: c.range,
                    points: c.points,
                    pointIndex: 0,
                    speed: c.speed,
                    moveProgress: 0
                }));
                
                // Setup paint cans
                this.paintCans = [];
                const availableSpots = [];
                for (let y = 2; y < GRID_SIZE - 2; y++) {
                    for (let x = 2; x < GRID_SIZE - 2; x++) {
                        if (!this.obstacles.has(`${x},${y}`) && (x !== 1 || y !== 1)) {
                            availableSpots.push({ x, y });
                        }
                    }
                }
                
                for (let i = 0; i < level.paintCans; i++) {
                    const spot = availableSpots.splice(Math.floor(Math.random() * availableSpots.length), 1)[0];
                    this.paintCans.push({ x: spot.x, y: spot.y, wobble: Math.random() * Math.PI * 2 });
                }
                
                this.paintedCount = 0;
                this.particles = [];
                
                // Update UI
                document.getElementById('levelNum').textContent = level.number;
                document.getElementById('targetPercent').textContent = level.target;
                this.updateProgress();
            },
            
            movePlayer(dir) {
                if (this.player.moving) return;
                
                this.player.direction = dir;
                const newX = this.player.x + (dir === 'left' ? -1 : dir === 'right' ? 1 : 0);
                const newY = this.player.y + (dir === 'up' ? -1 : dir === 'down' ? 1 : 0);
                
                if (this.isValidMove(newX, newY)) {
                    this.player.moving = true;
                    this.lastMoveTime = Date.now();
                    
                    setTimeout(() => {
                        this.player.x = newX;
                        this.player.y = newY;
                        this.player.moving = false;
                        
                        // Check paint can collection
                        const canIndex = this.paintCans.findIndex(c => c.x === newX && c.y === newY);
                        if (canIndex !== -1) {
                            this.paintCans.splice(canIndex, 1);
                            this.player.painted = true;
                            this.player.paintColor = Math.floor(Math.random() * COLORS.painted.length);
                            this.createPaintSplash(newX, newY);
                        }
                        
                        // Paint tile
                        if (this.player.painted && !this.grid[newY][newX].painted) {
                            this.grid[newY][newX].painted = true;
                            this.grid[newY][newX].color = this.player.paintColor;
                            this.paintedCount++;
                            this.updateProgress();
                            this.checkWinCondition();
                        }
                    }, this.moveDelay);
                }
            },
            
            hop() {
                if (this.player.moving) return;
                
                const dir = this.player.direction;
                const hopX = this.player.x + (dir === 'left' ? -1 : dir === 'right' ? 1 : 0);
                const hopY = this.player.y + (dir === 'up' ? -1 : dir === 'down' ? 1 : 0);
                
                if (hopX >= 0 && hopX < GRID_SIZE && hopY >= 0 && hopY < GRID_SIZE) {
                    this.player.moving = true;
                    this.player.hopAnimation = 1;
                    this.lastMoveTime = Date.now();
                    
                    setTimeout(() => {
                        this.player.x = hopX;
                        this.player.y = hopY;
                        this.player.moving = false;
                        this.player.hopAnimation = 0;
                        
                        // Check paint can collection
                        const canIndex = this.paintCans.findIndex(c => c.x === hopX && c.y === hopY);
                        if (canIndex !== -1) {
                            this.paintCans.splice(canIndex, 1);
                            this.player.painted = true;
                            this.player.paintColor = Math.floor(Math.random() * COLORS.painted.length);
                            this.createPaintSplash(hopX, hopY);
                        }
                        
                        // Paint tile
                        if (this.player.painted && !this.grid[hopY][hopX].painted) {
                            this.grid[hopY][hopX].painted = true;
                            this.grid[hopY][hopX].color = this.player.paintColor;
                            this.paintedCount++;
                            this.updateProgress();
                            this.checkWinCondition();
                        }
                    }, this.moveDelay);
                }
            },
            
            isValidMove(x, y) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
                if (this.obstacles.has(`${x},${y}`)) return false;
                return true;
            },
            
            updateCounselors(dt) {
                this.counselors.forEach(c => {
                    c.moveProgress += c.speed * dt;
                    
                    if (c.moveProgress >= 1) {
                        c.moveProgress = 0;
                        
                        if (c.patrol === 'horizontal') {
                            const nextX = c.x + (c.direction === 'right' ? 1 : -1);
                            if (nextX < c.range[0] || nextX > c.range[1]) {
                                c.direction = c.direction === 'right' ? 'left' : 'right';
                            } else {
                                c.x = nextX;
                            }
                        } else if (c.patrol === 'vertical') {
                            const nextY = c.y + (c.direction === 'down' ? 1 : -1);
                            if (nextY < c.range[0] || nextY > c.range[1]) {
                                c.direction = c.direction === 'down' ? 'up' : 'down';
                            } else {
                                c.y = nextY;
                            }
                        } else if (c.patrol === 'rectangle') {
                            c.pointIndex = (c.pointIndex + 1) % c.points.length;
                            const target = c.points[c.pointIndex];
                            const prev = c.points[(c.pointIndex - 1 + c.points.length) % c.points.length];
                            
                            if (target.x > prev.x) c.direction = 'right';
                            else if (target.x < prev.x) c.direction = 'left';
                            else if (target.y > prev.y) c.direction = 'down';
                            else if (target.y < prev.y) c.direction = 'up';
                            
                            c.x = target.x;
                            c.y = target.y;
                        }
                    }
                });
            },
            
            checkVisionCones() {
                for (let c of this.counselors) {
                    const visionTiles = this.getVisionCone(c);
                    if (visionTiles.some(t => t.x === this.player.x && t.y === this.player.y)) {
                        this.caught();
                        return;
                    }
                }
            },
            
            getVisionCone(counselor) {
                const tiles = [];
                const range = 4;
                
                for (let i = 1; i <= range; i++) {
                    for (let j = -i; j <= i; j++) {
                        let x = counselor.x;
                        let y = counselor.y;
                        
                        if (counselor.direction === 'right') {
                            x += i;
                            y += j;
                        } else if (counselor.direction === 'left') {
                            x -= i;
                            y += j;
                        } else if (counselor.direction === 'down') {
                            y += i;
                            x += j;
                        } else if (counselor.direction === 'up') {
                            y -= i;
                            x += j;
                        }
                        
                        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                            tiles.push({ x, y });
                        }
                    }
                }
                
                return tiles;
            },
            
            caught() {
                this.state = 'caught';
                this.screenShake = 20;
                
                const modal = document.createElement('div');
                modal.className = 'modal caught-overlay';
                modal.innerHTML = `
                    <h1>CAUGHT!</h1>
                    <p style="font-size: 48px;">üò±</p>
                    <p>A counselor spotted you!</p>
                    <button onclick="game.restartLevel()">TRY AGAIN</button>
                `;
                document.getElementById('gameContainer').appendChild(modal);
            },
            
            restartLevel() {
                document.querySelectorAll('.modal').forEach(m => {
                    if (m.id !== 'startModal') m.remove();
                });
                this.loadLevel();
                this.state = 'playing';
            },
            
            checkWinCondition() {
                const level = LEVELS[this.currentLevel];
                const totalTiles = GRID_SIZE * GRID_SIZE - this.obstacles.size;
                const paintedPercent = (this.paintedCount / totalTiles) * 100;
                
                if (paintedPercent >= level.target) {
                    this.levelComplete();
                }
            },
            
            levelComplete() {
                this.state = 'complete';
                
                const modal = document.createElement('div');
                modal.className = 'modal complete-overlay';
                
                const level = LEVELS[this.currentLevel];
                const totalTiles = GRID_SIZE * GRID_SIZE - this.obstacles.size;
                const paintedPercent = Math.floor((this.paintedCount / totalTiles) * 100);
                
                if (this.currentLevel < LEVELS.length - 1) {
                    modal.innerHTML = `
                        <h1>LEVEL COMPLETE!</h1>
                        <p style="font-size: 48px;">üéâ</p>
                        <p>Paint Coverage: ${paintedPercent}%</p>
                        <button onclick="game.nextLevel()">NEXT LEVEL</button>
                    `;
                } else {
                    modal.innerHTML = `
                        <h1>GAME COMPLETE!</h1>
                        <p style="font-size: 48px;">üèÜ</p>
                        <p>You painted all the levels!</p>
                        <p>Final Score: ${paintedPercent}%</p>
                        <button onclick="game.resetGame()">PLAY AGAIN</button>
                    `;
                }
                
                document.getElementById('gameContainer').appendChild(modal);
            },
            
            nextLevel() {
                document.querySelectorAll('.modal').forEach(m => {
                    if (m.id !== 'startModal') m.remove();
                });
                this.currentLevel++;
                this.loadLevel();
                this.state = 'playing';
            },
            
            resetGame() {
                document.querySelectorAll('.modal').forEach(m => {
                    if (m.id !== 'startModal') m.remove();
                });
                this.currentLevel = 0;
                this.loadLevel();
                this.state = 'playing';
            },
            
            updateProgress() {
                const level = LEVELS[this.currentLevel];
                const totalTiles = GRID_SIZE * GRID_SIZE - this.obstacles.size;
                const paintedPercent = Math.floor((this.paintedCount / totalTiles) * 100);
                
                const fill = document.getElementById('progressFill');
                fill.style.width = paintedPercent + '%';
                fill.textContent = paintedPercent + '%';
            },
            
            createPaintSplash(x, y) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: (x + 0.5) * TILE_SIZE,
                        y: (y + 0.5) * TILE_SIZE,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 1,
                        color: COLORS.painted[this.player.paintColor],
                        size: Math.random() * 3 + 2
                    });
                }
            },
            
            updateParticles(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= dt * 2;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },
            
            draw() {
                ctx.save();
                
                // Screen shake
                if (this.screenShake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * this.screenShake,
                        (Math.random() - 0.5) * this.screenShake
                    );
                    this.screenShake *= 0.9;
                }
                
                // Draw grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const tile = this.grid[y][x];
                        ctx.fillStyle = tile.painted ? COLORS.painted[tile.color] : COLORS.unpainted;
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                    }
                }
                
                // Draw obstacles
                ctx.fillStyle = COLORS.obstacle;
                this.obstacles.forEach(obs => {
                    const [x, y] = obs.split(',').map(Number);
                    ctx.fillRect(x * TILE_SIZE + 2, y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x * TILE_SIZE + 2, y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                });
                
                // Draw paint cans
                this.paintCans.forEach(can => {
                    can.wobble += 0.05;
                    const wobble = Math.sin(can.wobble) * 2;
                    
                    ctx.fillStyle = COLORS.paintCan;
                    ctx.beginPath();
                    ctx.arc((can.x + 0.5) * TILE_SIZE, (can.y + 0.5) * TILE_SIZE + wobble, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1C86EE';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Glow effect
                    ctx.strokeStyle = 'rgba(30, 144, 255, 0.3)';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                });
                
                // Draw vision cones
                this.counselors.forEach(c => {
                    const visionTiles = this.getVisionCone(c);
                    ctx.fillStyle = COLORS.visionCone;
                    visionTiles.forEach(t => {
                        ctx.fillRect(t.x * TILE_SIZE, t.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    });
                });
                
                // Draw counselors
                this.counselors.forEach(c => {
                    ctx.fillStyle = COLORS.counselor;
                    ctx.beginPath();
                    ctx.arc((c.x + 0.5) * TILE_SIZE, (c.y + 0.5) * TILE_SIZE, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.arc((c.x + 0.5) * TILE_SIZE, (c.y + 0.5) * TILE_SIZE, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Direction indicator
                    ctx.fillStyle = 'white';
                    const dirOffsets = {
                        right: [4, 0],
                        left: [-4, 0],
                        down: [0, 4],
                        up: [0, -4]
                    };
                    const [dx, dy] = dirOffsets[c.direction];
                    ctx.beginPath();
                    ctx.arc((c.x + 0.5) * TILE_SIZE + dx, (c.y + 0.5) * TILE_SIZE + dy, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw player
                const hopOffset = this.player.hopAnimation > 0 ? -Math.sin(this.player.hopAnimation * Math.PI) * 10 : 0;
                
                ctx.fillStyle = COLORS.player;
                ctx.beginPath();
                ctx.arc((this.player.x + 0.5) * TILE_SIZE, (this.player.y + 0.5) * TILE_SIZE + hopOffset, 10, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.player.painted) {
                    ctx.fillStyle = COLORS.painted[this.player.paintColor];
                    ctx.beginPath();
                    ctx.arc((this.player.x + 0.5) * TILE_SIZE, (this.player.y + 0.5) * TILE_SIZE + hopOffset, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc((this.player.x + 0.5) * TILE_SIZE - 3, (this.player.y + 0.5) * TILE_SIZE - 2 + hopOffset, 3, 0, Math.PI * 2);
                ctx.arc((this.player.x + 0.5) * TILE_SIZE + 3, (this.player.y + 0.5) * TILE_SIZE - 2 + hopOffset, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc((this.player.x + 0.5) * TILE_SIZE - 3, (this.player.y + 0.5) * TILE_SIZE - 2 + hopOffset, 1.5, 0, Math.PI * 2);
                ctx.arc((this.player.x + 0.5) * TILE_SIZE + 3, (this.player.y + 0.5) * TILE_SIZE - 2 + hopOffset, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw particles
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                ctx.restore();
            },
            
            gameLoop() {
                if (this.state === 'playing') {
                    const dt = 0.016;
                    this.updateCounselors(dt);
                    this.checkVisionCones();
                    this.updateParticles(dt);
                    
                    if (this.player.hopAnimation > 0) {
                        this.player.hopAnimation -= dt * 5;
                        if (this.player.hopAnimation < 0) this.player.hopAnimation = 0;
                    }
                }
                
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        };
        
        // Initialize game
        game.init();
    </script>
</body>
</html>