<!DOCTYPE html>
<html lang="en">
<head>

     <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JDJ9TGXZ7Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-JDJ9TGXZ7Q');
</script>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spirit Mahjong</title>
    <style>
        :root { --neon: #00f2ff; --sakura: #ffb7c5; }
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
    
    body {
        font-family: 'Segoe UI', sans-serif;
        background: #0d0221;
        color: white;
        /* Force body to be exactly the viewport height */
        height: 100vh;
        height: 100dvh; /* Better for mobile browsers */
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    #game-container {
        /* Ensure the container never exceeds the screen height */
        height: 100%;
        display: flex;
        flex-direction: column;
        padding: 10px;
        max-width: 1400px;
        margin: 0 auto;
        width: 100%;
    }

    .board-wrapper {
        /* This tells the board to take up all available space between header and buttons */
        flex: 1;
        position: relative;
        background: rgba(0, 0, 0, 0.4);
        border: 2px solid var(--neon);
        border-radius: 12px;
        box-shadow: 0 0 20px rgba(0, 242, 255, 0.1);
        overflow: hidden;
        min-height: 0; /* Critical for flexbox height calculation */
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .ui-top {
        flex-shrink: 0; /* Header won't disappear */
        display: flex;
        justify-content: space-between;
        padding: 10px 0;
        font-weight: bold;
        text-transform: uppercase;
    }

    .controls {
        flex-shrink: 0; /* Buttons won't disappear */
        display: flex;
        justify-content: center;
        gap: 10px;
        padding: 15px 0;
    }

    .btn {
        background: rgba(255,255,255,0.05);
        border: 1px solid var(--neon);
        color: white;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
    }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-top">
        <span>Tiles: <span id="count">0</span></span>
        <span style="color:var(--sakura)">Spirit Mahjong</span>
        <span id="timer">0:00</span>
    </div>

    <div class="board-wrapper" id="canvasParent">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls">
        <button class="btn" onclick="initGame()">Restart</button>
        <button class="btn" onclick="shuffle()">Shuffle</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const symbols = ['ðŸŒ¸', 'ðŸ¦Š', 'ðŸŒ€', 'âš”ï¸', 'ðŸ‘’', 'ðŸ®', 'ðŸŒ©ï¸', 'ðŸ¯', 'ðŸ‘ï¸', 'ðŸ‘»'];

let tiles = [];
let selected = null;
// We define a "Virtual" coordinate space (e.g., 1000 units wide)
// This ensures logic is the same on a 4K monitor and an iPhone.
let world = { w: 0, h: 0, scale: 1, offX: 0, offY: 0 };

function resize() {
    const parent = canvas.parentElement;
    // Sync canvas internal resolution with its CSS display size
    canvas.width = parent.clientWidth;
    canvas.height = parent.clientHeight;

    if (tiles.length === 0) return;

    // 1. Calculate the layout dimensions (including the pyramid overlap)
    const maxX = Math.max(...tiles.map(t => t.x)) + 1;
    const maxY = Math.max(...tiles.map(t => t.y)) + 1;

    // 2. Fit tiles into the current board space
    const tileW = 0.85; 
    const availableW = canvas.width / (maxX * tileW + 0.5);
    const availableH = canvas.height / (maxY + 0.5);
    
    // Scale is the maximum size we can go without hitting any wall
    world.scale = Math.min(availableW, availableH) * 0.95; 

    // 3. IMPROVED CENTERING: 
    // This math ensures the tiles are centered in the actual visible board
    world.offX = (canvas.width - (maxX * world.scale * tileW)) / 2;
    world.offY = (canvas.height - (maxY * world.scale)) / 2;
}

/**
 * Scrambles symbols of remaining tiles without moving them.
 */
function shuffle() {
    // 1. Get all tiles that are still on the board
    const activeTiles = tiles.filter(t => !t.matched);
    
    if (activeTiles.length === 0) return;

    // 2. Extract their symbols
    const remainingSymbols = activeTiles.map(t => t.symbol);

    // 3. Fisher-Yates Shuffle Algorithm
    for (let i = remainingSymbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [remainingSymbols[i], remainingSymbols[j]] = [remainingSymbols[j], remainingSymbols[i]];
    }

    // 4. Re-assign symbols to the tiles
    activeTiles.forEach((tile, index) => {
        tile.symbol = remainingSymbols[index];
    });

    // 5. Clear selection to prevent matching old symbols
    selected = null;
}

// Update the pointer listener to handle both mouse and touch correctly
canvas.addEventListener('pointerdown', handleClick);


function initGame() {
    const layout = [];
    for(let z=0; z<3; z++) {
        const dim = 5 - z;
        for(let x=0; x<dim; x++) {
            for(let y=0; y<dim; y++) {
                // Centering layers on top of each other
                layout.push({ x: x + (z*0.5), y: y + (z*0.5), z: z });
            }
        }
    }

    if(layout.length % 2 !== 0) layout.pop();
    
    let deck = [];
    for(let i=0; i<layout.length/2; i++) {
        const s = symbols[i % symbols.length];
        deck.push(s, s);
    }
    deck.sort(() => Math.random() - 0.5);

    tiles = layout.map((pos, i) => ({
        ...pos, symbol: deck[i], matched: false, id: i
    }));

    document.getElementById('count').innerText = tiles.length;
    resize();
}

function getTileRect(t) {
    const sz = world.scale;
    const depth = t.z * (sz * 0.1); // 3D height effect
    return {
        x: world.offX + (t.x * sz * 0.85) - depth,
        y: world.offY + (t.y * sz) - depth,
        w: sz * 0.8,
        h: sz
    };
}

function handleClick(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
    const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

    // Precise mapping of click to canvas pixels
    const mouseX = (clientX - rect.left) * (canvas.width / rect.width);
    const mouseY = (clientY - rect.top) * (canvas.height / rect.height);

    // Find clicked tile (Top-down search)
    let clickedTile = null;
    const active = tiles.filter(t => !t.matched).sort((a,b) => b.z - a.z);

    for (let t of active) {
        const r = getTileRect(t);
        if (mouseX >= r.x && mouseX <= r.x + r.w && mouseY >= r.y && mouseY <= r.y + r.h) {
            clickedTile = t;
            break; 
        }
    }

    if (clickedTile && isFree(clickedTile)) {
        if (selected && selected !== clickedTile && selected.symbol === clickedTile.symbol) {
            clickedTile.matched = selected.matched = true;
            selected = null;
        } else {
            selected = clickedTile;
        }
        document.getElementById('count').innerText = tiles.filter(t => !t.matched).length;
    } else {
        selected = null;
    }
}

// Logic for blocked tiles
function isFree(t) {
    if (t.matched) return false;
    const onTop = tiles.some(o => !o.matched && o.z === t.z + 1 && Math.abs(o.x - t.x) < 0.6 && Math.abs(o.y - t.y) < 0.6);
    if (onTop) return false;
    const left = tiles.some(o => !o.matched && o.z === t.z && o.x === t.x - 1 && Math.abs(o.y - t.y) < 0.2);
    const right = tiles.some(o => !o.matched && o.z === t.z && o.x === t.x + 1 && Math.abs(o.y - t.y) < 0.2);
    return !left || !right;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const renderList = tiles.filter(t => !t.matched).sort((a,b) => a.z - b.z || a.x - b.x);
    
    renderList.forEach(t => {
        const r = getTileRect(t);
        const free = isFree(t);

        // 3D Side Shadow
        ctx.fillStyle = '#99a';
        ctx.fillRect(r.x + (world.scale*0.06), r.y + (world.scale*0.06), r.w, r.h);

        // Tile Face
        ctx.fillStyle = free ? (selected === t ? '#ffb7c5' : '#ffffff') : '#666';
        ctx.strokeStyle = '#00f2ff';
        ctx.lineWidth = Math.max(1, world.scale * 0.03);
        
        ctx.beginPath();
        ctx.roundRect(r.x, r.y, r.w, r.h, world.scale * 0.1);
        ctx.fill();
        ctx.stroke();

        // Symbol
        ctx.fillStyle = free ? '#000' : '#444';
        ctx.font = `bold ${r.h * 0.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(t.symbol, r.x + r.w/2, r.y + r.h/2);
    });

    requestAnimationFrame(draw);
}

// IMPORTANT: Ensure resize is called after everything is ready
window.addEventListener('load', () => {
    initGame();
    draw();
});
window.addEventListener('resize', resize);
</script>
</body>
</html>